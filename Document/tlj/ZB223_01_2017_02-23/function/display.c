#define DISPLAY_C
#include "display.h" 

/***************************************************************
* uint16 disX 坐标
* uint16 disY
* uint32 lutAddr
****************************************************************/
const PIC_INFO_STRUCT PicInfo[700]@".__LCDCONFIG_DATA"=        
{                                              
/***************************************************首页图片  (0~0b0000M) **************************************************************/
    {0,0,    0x000000+0x10+0x000000  ,0X400,1,0,     0x000000+0x410+0x000000,4,8 ,0x0070,0x0320},  // 仪表图标        0
    {160,130,0x006DFA+0x10+0x000000  ,0X400,1,0x100, 0x006DFA+0x410+0x000000,0,8, 0x0091,0x01E1},  // 前门开后门开    1
    {160,130,0x006DFA+0x10+0x011481  ,0X400,1,0x100, 0x006DFA+0x410+0x011481,0,8, 0x0091,0x01E1},  // 前门关后门关    2
    {160,130,0x006DFA+0x10+0x022902  ,0X400,1,0x100, 0x006DFA+0x410+0x022902,0,8, 0x0091,0x01E1},  // 前门关后门开    3
    {160,130,0x006DFA+0x10+0x033D83  ,0X400,1,0x100, 0x006DFA+0x410+0x033D83,0,8, 0x0091,0x01E1},  // 前门开后门关    4
    {15,190, 0x006DFA+0x10+0x045204  ,0X400,1,0x100, 0x006DFA+0x410+0x045204,0,8, 0x00B0,0x003C},  // 油量指示1-1     5
    {15,190, 0x006DFA+0x10+0x047F54  ,0X400,1,0x100, 0x006DFA+0x410+0x047F54,0,8, 0x00B0,0x003C},  // 油量指示2       6
    {15,190, 0x006DFA+0x10+0x04ACA4  ,0X400,1,0x100, 0x006DFA+0x410+0x04ACA4,0,8, 0x00B0,0x003C},  // 油量指示3       7
    {15,190, 0x006DFA+0x10+0x04D9F4  ,0X400,1,0x100, 0x006DFA+0x410+0x04D9F4,0,8, 0x00B0,0x003C},  // 油量指示4       8
    {15,190, 0x006DFA+0x10+0x050744  ,0X400,1,0x100, 0x006DFA+0x410+0x050744,0,8, 0x00B0,0x003C},  // 油量指示5       9
    {15,190, 0x006DFA+0x10+0x053494  ,0X400,1,0x100, 0x006DFA+0x410+0x053494,0,8, 0x00B0,0x003C},  // 油量指示6       10
    {15,190, 0x006DFA+0x10+0x0561E4  ,0X400,1,0x100, 0x006DFA+0x410+0x0561E4,0,8, 0x00B0,0x003C},  // 油量指示7-0     11
    {15,190, 0x006DFA+0x10+0x058F34  ,0X400,1,0x100, 0x006DFA+0x410+0x058F34,0,8, 0x00B0,0x003C},  // 油量指示7-1     12
    {15,190, 0x006DFA+0x10+0x05BC84  ,0X400,1,0x100, 0x006DFA+0x410+0x05BC84,0,8, 0x00B0,0x003C},  // 油量指示8       13
    {15,190, 0x006DFA+0x10+0x05E9D4  ,0X400,1,0x100, 0x006DFA+0x410+0x05E9D4,0,8, 0x00B0,0x003C},  // 油量指示9       14
    {15,190, 0x006DFA+0x10+0x061724  ,0X400,1,0x100, 0x006DFA+0x410+0x061724,0,8, 0x00B0,0x003C},  // 油量指示10      15
    {15,190, 0x006DFA+0x10+0x064474  ,0X400,1,0x100, 0x006DFA+0x410+0x064474,0,8, 0x00B0,0x003C},  // 油量指示1-0     16
    {720,190,0x006DFA+0x10+0x0671C4  ,0X400,1,0x100, 0x006DFA+0x410+0x0671C4,0,8, 0x00B0,0x003C},  // 电量指示1       17
    {720,190,0x006DFA+0x10+0x069F14  ,0X400,1,0x100, 0x006DFA+0x410+0x069F14,0,8, 0x00B0,0x003C},  // 电量指示2       18
    {720,190,0x006DFA+0x10+0x06CC64  ,0X400,1,0x100, 0x006DFA+0x410+0x06CC64,0,8, 0x00B0,0x003C},  // 电量指示3       19
    {720,190,0x006DFA+0x10+0x06F9B4  ,0X400,1,0x100, 0x006DFA+0x410+0x06F9B4,0,8, 0x00B0,0x003C},  // 电量指示4       20
    {720,190,0x006DFA+0x10+0x072704  ,0X400,1,0x100, 0x006DFA+0x410+0x072704,0,8, 0x00B0,0x003C},  // 电量指示5       21
    {720,190,0x006DFA+0x10+0x075454  ,0X400,1,0x100, 0x006DFA+0x410+0x075454,0,8, 0x00B0,0x003C},  // 电量指示6       22
    {720,190,0x006DFA+0x10+0x0781A4  ,0X400,1,0x100, 0x006DFA+0x410+0x0781A4,0,8, 0x00B0,0x003C},  // 电量指示7       23
    {720,190,0x006DFA+0x10+0x07AEF4  ,0X400,1,0x100, 0x006DFA+0x410+0x07AEF4,0,8, 0x00B0,0x003C},  // 电量指示8       24
    {720,190,0x006DFA+0x10+0x07DC44  ,0X400,1,0x100, 0x006DFA+0x410+0x07DC44,0,8, 0x00B0,0x003C},  // 电量指示9       25
    {720,190,0x006DFA+0x10+0x080994  ,0X400,1,0x100, 0x006DFA+0x410+0x080994,0,8, 0x00B0,0x003C},  // 电量指示10      26
    {1,394,  0x00089241,  0X400,1,0x100, 0x00089641,0,8, 0x0055,0x0316},  // 首界面          27
/***************************************************主菜单图片 (0b0000~150000) *********************************************************/                    
    {0, 0,   0x000c1130,  0x400,1,0, 0x000C1530,2,8, 0x01E0,0x0320},    // 菜单            28             
    {0,0,    0x125154+0x10+0x000000,  0X400,1,0,     0x125154+0x410+0x000000,2,8 ,0x01E0,0x0320},     // 菜单2           29   菜单2 
    {20, 30, 0x1527FD+0x10+0x000000,  0x400,1,0x100, 0x1527FD+0x410+0x000000,0,8, 0x00A3,0x00A6},    // 1 // 故障查询   30   控件一
    {220,30, 0x1527FD+0x10+0x006DC2,  0x400,1,0x100, 0x1527FD+0x410+0x006DC2,0,8, 0x00A3,0x00A6},    // 1 // 系统诊断   31   控件二
    {418,30, 0x1527FD+0x10+0x00DB84,  0x400,1,0x100, 0x1527FD+0x410+0x00DB84,0,8, 0x00A3,0x00A6},    // 1 // 参数设置   32   控件三
    {612,30, 0x1527FD+0x10+0x014946,  0x400,1,0x100, 0x1527FD+0x410+0x014946,0,8, 0x00A3,0x00A6},    // 1 // 里程油耗   33   控件四
    {20, 250,0x1527FD+0x10+0x01B708,  0x400,1,0x100, 0x1527FD+0x410+0x01B708,0,8, 0x00A3,0x00A6},    // 1 // 图像设置   34   控件五
    {220,250,0x1527FD+0x10+0x0224CA,  0x400,1,0x100, 0x1527FD+0x410+0x0224CA,0,8, 0x00A3,0x00A6},    // 1 // 时间设置   35   控件六
    {420,250,0x1527FD+0x10+0x02928C,  0x400,1,0x100, 0x1527FD+0x410+0x02928C,0,8, 0x00A3,0x00A6},    // 1 // 胎压查询   36   控件七
    {600,250,0x1527FD+0x10+0x03004E,  0x400,1,0x100, 0x1527FD+0x410+0x03004E,0,8, 0x00A3,0x00A6},    // 1 // 帮助信息   37   控件八         
    {20, 30, 0x1527FD+0x10+0x000000,  0x400,1,0x100, 0x1527FD+0x410+0x000000,0,8, 0x00A3,0x00A6},    // 1 // 故障查询   38   控件一
    {200,30, 0x1527FD+0x10+0x006DC2,  0x400,1,0x100, 0x1527FD+0x410+0x006DC2,0,8, 0x00A3,0x00A6},    // 1 // 系统诊断   39   控件二
    {400,30, 0x1527FD+0x10+0x00DB84,  0x400,1,0x100, 0x1527FD+0x410+0x00DB84,0,8, 0x00A3,0x00A6},    // 1 // 参数设置   40   控件三
    {600,30, 0x1527FD+0x10+0x014946,  0x400,1,0x100, 0x1527FD+0x410+0x014946,0,8, 0x00A3,0x00A6},    // 1 // 里程油耗   41   控件四
    {20, 250,0x1527FD+0x10+0x01B708,  0x400,1,0x100, 0x1527FD+0x410+0x01B708,0,8, 0x00A3,0x00A6},    // 1 // 图像设置   42   控件五
    {200,250,0x1527FD+0x10+0x0224CA,  0x400,1,0x100, 0x1527FD+0x410+0x0224CA,0,8, 0x00A3,0x00A6},    // 1 // 时间设置   43   控件六
    {400,250,0x1527FD+0x10+0x02928C,  0x400,1,0x100, 0x1527FD+0x410+0x02928C,0,8, 0x00A3,0x00A6},    // 1 // 胎压查询   44   控件七
    {600,250,0x1527FD+0x10+0x03004E,  0x400,1,0x100, 0x1527FD+0x410+0x03004E,0,8, 0x00A3,0x00A6},    // 1 // 帮助信息   45   控件八
/***************************************************故障查询图片 (0x150000~0x500000) *********************************************************/  
    {0,0,    0x13432A+0x10+0x000000,  0X400,1,0,     0x13432A+0x410+0x000000,6,8 ,0x01E0,0x0320},     // 故障查询菜单   46 
                 
/***************************************************诊断菜单图片 (0x500000~0x580000) *********************************************************/                            
    {0,    0,   0x705332+0x10+0x000000,  0X400,1,0,     0x705332+0x410+0x000000,5,8 ,0x01E0,0x0320},    // 1 // 诊断菜单   47 
    {60,   90,  0x725B91+0x10+0x000000,  0x400,1,0x100, 0x725B91+0x410+0x000000,0,8, 0x0038,0x013c},    // 1 // 仪表       48
    {58,   175, 0x725B91+0x10+0x004930,  0x400,1,0x100, 0x725B91+0x410+0x004930,0,8, 0x0038,0x013c},    // 1 // 前驱       49
    {56,   260, 0x725B91+0x10+0x009260,  0x400,1,0x100, 0x725B91+0x410+0x009260,0,8, 0x0038,0x013c},    // 1 // 后驱       50
    {54,   340, 0x725B91+0x10+0x00DB90,  0x400,1,0x100, 0x725B91+0x410+0x00DB90,0,8, 0x0038,0x013c},    // 1 // 顶驱       51 
    {430,  90 , 0x725B91+0x10+0x0124C0 , 0x400,1,0x100, 0x725B91+0x410+0x0124C0,0,8, 0x0038,0x013c},    // 1 // 配电       52 
    {428,  175, 0x725B91+0x10+0x016DF0,  0x400,1,0x100, 0x725B91+0x410+0x016DF0,0,8, 0x0038,0x013c},    // 1 // 模块温度   53
    {426,  260, 0x725B91+0x10+0x01B720,  0x400,1,0x100, 0x725B91+0x410+0x01B720,0,8, 0x0038,0x013c},    // 1 // 集中润滑   54
    {424,  340, 0x725B91+0x10+0x020050,  0x400,1,0x100, 0x725B91+0x410+0x020050,0,8, 0x0038,0x013c},    // 1 // 发动机     55 
/***************************************************诊断内容图片 (0x580000~0x900000) *********************************************************/          
    {0, 0 ,0x74A511+0x10+0x000000,  0x400,1,0, 0x74A511+0x410+0x000000,2,8, 0x01E0,0x0320},    // 1 // 仪表内容1   56
    {0, 0 ,0x74A511+0x10+0x041DAE,  0x400,1,0, 0x74A511+0x410+0x041DAE,2,8, 0x01E0,0x0320},    // 1 // 仪表内容2   57
    {0, 0 ,0x74A511+0x10+0x082559,  0x400,1,0, 0x74A511+0x410+0x082559,2,8, 0x01E0,0x0320},    // 1 // 仪表内容3   58
    {0, 0 ,0x74A511+0x10+0x0C1600,  0x400,1,0, 0x74A511+0x410+0x0C1600,2,8, 0x01E0,0x0320},    // 1 // 前控内容1   59 
    {0, 0 ,0x74A511+0x10+0x10256B,  0x400,1,0, 0x74A511+0x410+0x10256B,2,8, 0x01E0,0x0320},    // 1 // 前驱状态2   60
    {0, 0 ,0x74A511+0x10+0x142F72,  0x400,1,0, 0x74A511+0x410+0x142F72,2,8, 0x01E0,0x0320},    // 1 // 后控状态1   61
    {0, 0 ,0x74A511+0x10+0x183AD3,  0x400,1,0, 0x74A511+0x410+0x183AD3,2,8, 0x01E0,0x0320},    // 1 // 后控内容2   62
    {0, 0 ,0x74A511+0x10+0x1C4CF1,  0x400,1,0, 0x74A511+0x410+0x1C4CF1,2,8, 0x01E0,0x0320},    // 1 // 顶控状态1   63
    {0, 0 ,0x74A511+0x10+0x205723,  0x400,1,0, 0x74A511+0x410+0x205723,2,8, 0x01E0,0x0320},    // 1 // 顶控内容2   64    
    {0, 0 ,0x74A511+0x10+0x24603E,  0x400,1,0, 0x74A511+0x410+0x24603E,6,8, 0x01E0,0x0320},    // 1 // 配电内容1   65
    {0, 0 ,0x74A511+0x10+0x258495,  0x400,1,0, 0x74A511+0x410+0x258495,7,8, 0x01E0,0x0320},    // 1 // 配电内容2   66
    {0, 0 ,0x74A511+0x10+0x2694AE,  0x400,1,0, 0x74A511+0x410+0x2694AE,7,8, 0x01E0,0x0320},    // 1 // 配电内容2   67
                
    
    
/***************************************************参数设置图片 (0x900000~0x9a0000) *********************************************************/    
    {0,    0,0x900000+0x10+0x000000,  0X400,1,0,     0x900000+0x410+0x000000,6,8,0x01E0,0x0320},      // 参数设置头部   68   
    {142,106,0x920000+0x10+0x000000,  0x400,1,0x100, 0x920000+0x410+0x000000,0,8, 0x0038,0x020E},    // 1 雨刮间歇时间  69
    {142,185,0x920000+0x10+0x007720,  0x400,1,0x100, 0x920000+0x410+0x007720,0,8, 0x0038,0x020E},    // 1 仪表背光      70
    {142,260,0x920000+0x10+0x00EE40,  0x400,1,0x100, 0x920000+0x410+0x00EE40,0,8, 0x0038,0x020E},    // 1 蜂鸣器音量    71
    {142,336,0x920000+0x10+0x016560,  0x400,1,0x100, 0x920000+0x410+0x016560,0,8, 0x0038,0x020E},    // 1 日期-被点中   72                                                                          
    {129,128,0x908000+0x10+0x05B57E,  0x400,1,0x100, 0x908000+0x410+0x05B57E,0,8, 0x0038,0x0204},    // 1 备用     73 (500k)
    {129,205,0x908000+0x10+0x062A6E,  0x400,1,0x100, 0x908000+0x410+0x062A6E,0,8, 0x0038,0x0204},    // 1 备用     74
    {129,282,0x908000+0x10+0x069F5E,  0x400,1,0x100, 0x908000+0x410+0x069F5E,0,8, 0x0038,0x0204},    // 1 备用     75
    {163,150,0x908000+0x10+0x07144E,  0x400,1,0x100, 0x908000+0x410+0x07144E,0,8, 0x003F,0x01C0},    // 1 备用     76   

    {0,0,    0x9a0000+0x10+0x000000,  0X400,1,0,     0x9a0000+0x410+0x000000,7,8, 0x01E0,0x0320},    //里程油耗           77         
    {0,0,    0x9a0000+0x10+0x010684,  0x400,1,0,     0x9a0000+0x410+0x010684,8,8, 0x01E0,0x0320},    //里程油耗1            78 
    {0,0,    0x908000+0x10+0x060C9C,  0x400,1,0,     0x908000+0x410+0x060C9C,0,8, 0x0028,0x0058},    // 备用              79   
    
                
    {0, 0,    0xAA1427+0x10+0x000000,  0X400,1,0,     0xAA1427+0x410+0x000000,5,8 ,0x01E0,0x0320},  //80
    {0, 0,    0xAA1427+0x10+0x01C14B,  0X400,1,0,     0xAA1427+0x410+0x01C14B,7,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x02F092,  0X400,1,0,     0xAA1427+0x410+0x02F092,6,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x042116,  0X400,1,0,     0xAA1427+0x410+0x042116,6,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x0553A1,  0X400,1,0,     0xAA1427+0x410+0x0553A1,6,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x06C43C,  0X400,1,0,     0xAA1427+0x410+0x06C43C,6,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x0836B7,  0X400,1,0,     0xAA1427+0x410+0x0836B7,7,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x08F722,  0X400,1,0,     0xAA1427+0x410+0x08F722,6,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x0A5663,  0X400,1,0,     0xAA1427+0x410+0x0A5663,6,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x0BB89E,  0X400,1,0,     0xAA1427+0x410+0x0BB89E,7,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x0C7139,  0X400,1,0,     0xAA1427+0x410+0x0C7139,7,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x0D6269,  0X400,1,0,     0xAA1427+0x410+0x0D6269,10,8 ,0x01E0,0x0320},
    {0, 0,    0xAA1427+0x10+0x0D6269,  0X400,1,0,     0xAA1427+0x410+0x000000,7,8 ,0x01E0,0x0320},

    
   
    {0, 0,   0xA80000+0x10+0x000000,  0X400,1,0,     0xA80000+0x410+0x000000,0x0a,8 ,0x01e0,0x0320},    // 电源管理背景      93 
    {0, 60,  0xA88000+0x10+0x000000,  0x400,1,0x100, 0xA88000+0x410+0x000000,   0,8, 0x0140,0x0320},    // 电源管理设置      94    
   
    {0, 0,   0xA4C78B+0x10+0x000000,  0X400,1,0,     0xA4C78B+0x410+0x000000,9,8 ,0x01e0,0x0320},      // 帮助              95
    {0, 0,   0xA4C78B+0x10+0x00A46A,  0x400,1,0,     0xA4C78B+0x410+0x00A46A,6,8, 0x01e0,0x0320},       //                   96
    
     
    { 0,286 ,   0x143A52+0x10+0x000000,   0x400,1,0x100, 0x143A52+0x410+0x000000,0,8, 0x0028,0x01c2  },    // 0  祝您一路平安      
    { 0, 336  , 0x143A52+0x10+0x004A60,   0x400,1,0x100, 0x143A52+0x410+0x004A60,0,8, 0x0028,0x01c2  },    // 1  无前驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x0094C0,   0x400,1,0x100, 0x143A52+0x410+0x0094C0,0,8, 0x0028,0x01c2  },    // 2  无后驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x00DF20,   0x400,1,0x100, 0x143A52+0x410+0x00DF20,0,8, 0x0028,0x01c2  },    // 3  无中驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x012980,   0x400,1,0x100, 0x143A52+0x410+0x012980,0,8, 0x0028,0x01c2  },    // 4  无顶驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x0173E0,   0x400,1,0x100, 0x143A52+0x410+0x0173E0,0,8, 0x0028,0x01c2  },    // 5  无配电模块报警     
    { 0, 336  , 0x143A52+0x10+0x01BE40,   0x400,1,0x100, 0x143A52+0x410+0x01BE40,0,8, 0x0028,0x01c2  },    // 6  E C U通信故障                     
    { 0, 336  , 0x143A52+0x10+0x0208A0,   0x400,1,0x100, 0x143A52+0x410+0x0208A0,0,8, 0x0028,0x01c2  },    // 7  备用模块1报警     
    { 0, 336  , 0x143A52+0x10+0x025300,   0x400,1,0x100, 0x143A52+0x410+0x025300,0,8, 0x0028,0x01c2  },    // 8  备用模块2报警 
    { 0, 336  , 0x143A52+0x10+0x029D60,   0x400,1,0x100, 0x143A52+0x410+0x029D60,0,8, 0x0028,0x01c2  },    // 9  备用模块3报警     
    { 0, 336  , 0x143A52+0x10+0x02E7C0,   0x400,1,0x100, 0x143A52+0x410+0x02E7C0,0,8, 0x0028,0x01c2  },    // 10 备用模块4报警  
       
    { 0, 336  , 0x143A52+0x10+0x033220,   0x400,1,0x100, 0x143A52+0x410+0x033220,0,8, 0x0028,0x01c2  },    // 11 发动机仓火警指示灯
    { 0, 336  , 0x143A52+0x10+0x037C80,   0x400,1,0x100, 0x143A52+0x410+0x037C80,0,8, 0x0028,0x01c2  },    // 12 蹄片报警指示灯     
    { 0, 336  , 0x143A52+0x10+0x03C6E0,   0x400,1,0x100, 0x143A52+0x410+0x03C6E0,0,8, 0x0028,0x01c2  },    // 13 发动机充电指示   
    { 0, 336  , 0x143A52+0x10+0x041140,   0x400,1,0x100, 0x143A52+0x410+0x041140,0,8, 0x0028,0x01c2  },    // 14 缓速器工作指示   
    { 0, 336  , 0x143A52+0x10+0x045BA0,   0x400,1,0x100, 0x143A52+0x410+0x045BA0,0,8, 0x0028,0x01c2  },    // 15 刹车灯指示   
    { 0, 336  , 0x143A52+0x10+0x04A600,   0x400,1,0x100, 0x143A52+0x410+0x04A600,0,8, 0x0028,0x01c2  },    // 16 变速箱故障指示 
    { 0, 336  , 0x143A52+0x10+0x04F060,   0x400,1,0x100, 0x143A52+0x410+0x04F060,0,8, 0x0028,0x01c2  },    // 17 位置灯指示 
    { 0, 336  , 0x143A52+0x10+0x053AC0,   0x400,1,0x100, 0x143A52+0x410+0x053AC0,0,8, 0x0028,0x01c2  },    // 18 空档指示 
    { 0, 336  , 0x143A52+0x10+0x058520,   0x400,1,0x100, 0x143A52+0x410+0x058520,0,8, 0x0028,0x01c2  },    // 19 前进档提示 
    { 0, 336  , 0x143A52+0x10+0x05CF80,   0x400,1,0x100, 0x143A52+0x410+0x05CF80,0,8, 0x0028,0x01c2  },    // 20 倒档提示     
    { 0, 336  , 0x143A52+0x10+0x0619E0,   0x400,1,0x100, 0x143A52+0x410+0x0619E0,0,8, 0x0028,0x01c2  },    // 21 消音状态关指示  
    { 0, 336  , 0x143A52+0x10+0x066440,   0x400,1,0x100, 0x143A52+0x410+0x066440,0,8, 0x0028,0x01c2  },    // 22 消音状态开指示   
    { 0, 336  , 0x143A52+0x10+0x06AEA0,   0x400,1,0x100, 0x143A52+0x410+0x06AEA0,0,8, 0x0028,0x01c2  },    // 23 门应急报警指示
    { 0, 336  , 0x143A52+0x10+0x06F900,   0x400,1,0x100, 0x143A52+0x410+0x06F900,0,8, 0x0028,0x01c2  },    // 24 干燥器指示   
    { 0, 336  , 0x143A52+0x10+0x074360,   0x400,1,0x100, 0x143A52+0x410+0x074360,0,8, 0x0028,0x01c2  },    // 25 发动机故障指示灯     
    { 0, 336  , 0x143A52+0x10+0x078DC0,   0x400,1,0x100, 0x143A52+0x410+0x078DC0,0,8, 0x0028,0x01c2  },    // 26 空滤报警指示  
    { 0, 336  , 0x143A52+0x10+0x07D820,   0x400,1,0x100, 0x143A52+0x410+0x07D820,0,8, 0x0028,0x01c2  },    // 27 气压报警   
    { 0, 336  , 0x143A52+0x10+0x082280,   0x400,1,0x100, 0x143A52+0x410+0x082280,0,8, 0x0028,0x01c2  },    // 28 ASR故障指示           
    { 0, 336  , 0x143A52+0x10+0x086CE0,   0x400,1,0x100, 0x143A52+0x410+0x086CE0,0,8, 0x0028,0x01c2  },    // 29 尿素液位低  
    { 0, 336  , 0x143A52+0x10+0x08B740,   0x400,1,0x100, 0x143A52+0x410+0x08B740,0,8, 0x0028,0x01c2  },    // 30 左前、后蹄片报警    
    { 0, 336  , 0x143A52+0x10+0x0901A0,   0x400,1,0x100, 0x143A52+0x410+0x0901A0,0,8, 0x0028,0x01c2  },    // 31 右前、后蹄片报警   
    { 0, 336  , 0x143A52+0x10+0x094C00,   0x400,1,0x100, 0x143A52+0x410+0x094C00,0,8, 0x0028,0x01c2  },    // 32 OBD MIL指示灯 
    { 0, 336  , 0x143A52+0x10+0x099660,   0x400,1,0x100, 0x143A52+0x410+0x099660,0,8, 0x0028,0x01c2  },    // 33 水位报警   
    { 0, 336  , 0x143A52+0x10+0x09E0C0,   0x400,1,0x100, 0x143A52+0x410+0x09E0C0,0,8, 0x0028,0x01c2  },    // 34 清里程小计指示  
    { 0, 336  , 0x143A52+0x10+0x0A2B20,   0x400,1,0x100, 0x143A52+0x410+0x0A2B20,0,8, 0x0028,0x01c2  },    // 35 总电源指示       
    { 0, 336  , 0x143A52+0x10+0x0A7580,   0x400,1,0x100, 0x143A52+0x410+0x0A7580,0,8, 0x0028,0x01c2  },    // 36 轻微故障指示灯     
    { 0, 336  , 0x143A52+0x10+0x0ABFE0,   0x400,1,0x100, 0x143A52+0x410+0x0ABFE0,0,8, 0x0028,0x01c2  },    // 37 近光灯指示   
    { 0, 336  , 0x143A52+0x10+0x0B0A40,   0x400,1,0x100, 0x143A52+0x410+0x0B0A40,0,8, 0x0028,0x01c2  },    // 38 远光灯指示 
    { 0, 336  , 0x143A52+0x10+0x0B54A0,   0x400,1,0x100, 0x143A52+0x410+0x0B54A0,0,8, 0x0028,0x01c2  },    // 39 左转向灯指示 
    { 0, 336  , 0x143A52+0x10+0x0B9F00,   0x400,1,0x100, 0x143A52+0x410+0x0B9F00,0,8, 0x0028,0x01c2  },    // 40 水温报警 
    { 0, 336  , 0x143A52+0x10+0x0BE960,   0x400,1,0x100, 0x143A52+0x410+0x0BE960,0,8, 0x0028,0x01c2  },    // 41 驻车符号指示
    { 0, 336  , 0x143A52+0x10+0x0C33C0,   0x400,1,0x100, 0x143A52+0x410+0x0C33C0,0,8, 0x0028,0x01c2  },    // 42 发动机预热指示
    { 0, 336  , 0x143A52+0x10+0x0C7E20,   0x400,1,0x100, 0x143A52+0x410+0x0C7E20,0,8, 0x0028,0x01c2  },    // 43 发动机仓门开指示
    { 0, 336  , 0x143A52+0x10+0x0CC880,   0x400,1,0x100, 0x143A52+0x410+0x0CC880,0,8, 0x0028,0x01c2  },    // 44 发动机MIL指示灯                                    
    { 0, 336  , 0x143A52+0x10+0x0D12E0,   0x400,1,0x100, 0x143A52+0x410+0x0D12E0,0,8, 0x0028,0x01c2  },    // 45 ABS故障指示
    { 0, 336  , 0x143A52+0x10+0x0D5D40,   0x400,1,0x100, 0x143A52+0x410+0x0D5D40,0,8, 0x0028,0x01c2  },    // 46 油量报警指示
    { 0, 336  , 0x143A52+0x10+0x0DA7A0,   0x400,1,0x100, 0x143A52+0x410+0x0DA7A0,0,8, 0x0028,0x01c2  },    // 47 右转向灯符号片  
    { 0, 336  , 0x143A52+0x10+0x0DF200,   0x400,1,0x100, 0x143A52+0x410+0x0DF200,0,8, 0x0028,0x01c2  },    // 48 后雾灯符号片                                                                                                                        
    { 0, 336  , 0x143A52+0x10+0x0E3C60,   0x400,1,0x100, 0x143A52+0x410+0x0E3C60,0,8, 0x0028,0x01c2  },    // 49 前雾灯符号片
    { 0, 336  , 0x143A52+0x10+0x0E86C0,   0x400,1,0x100, 0x143A52+0x410+0x0E86C0,0,8, 0x0028,0x01c2  },    // 50 二级故障指示灯
    { 0, 336  , 0x143A52+0x10+0x0ED120,   0x400,1,0x100, 0x143A52+0x410+0x0ED120,0,8, 0x0028,0x01c2  },    // 51 左边柱状报警       
    { 0, 336  , 0x143A52+0x10+0x0F1B80,   0x400,1,0x100, 0x143A52+0x410+0x0F1B80,0,8, 0x0028,0x01c2  },    // 52 右边柱状报警       
    { 0, 336  , 0x143A52+0x10+0x0F65E0,   0x400,1,0x100, 0x143A52+0x410+0x0F65E0,0,8, 0x0028,0x01c2  },    // 53 前门开            
    { 0, 336  , 0x143A52+0x10+0x0FB040,   0x400,1,0x100, 0x143A52+0x410+0x0FB040,0,8, 0x0028,0x01c2  },    // 54 中门开            
    { 0, 336  , 0x143A52+0x10+0x0FFAA0,   0x400,1,0x100, 0x143A52+0x410+0x0FFAA0,0,8, 0x0028,0x01c2  },    // 55 车速报警灯        
    { 0, 336  , 0x143A52+0x10+0x104500,   0x400,1,0x100, 0x143A52+0x410+0x104500,0,8, 0x0028,0x01c2  },    // 56 转速报警灯         
    { 0, 336  , 0x143A52+0x10+0x108F60,   0x400,1,0x100, 0x143A52+0x410+0x108F60,0,8, 0x0028,0x01c2  },    // 57 前气压报警             
    { 0, 336  , 0x143A52+0x10+0x10D9C0,   0x400,1,0x100, 0x143A52+0x410+0x10D9C0,0,8, 0x0028,0x01c2  },    // 58 后气压报警             
    { 0, 336  , 0x143A52+0x10+0x112420,   0x400,1,0x100, 0x143A52+0x410+0x112420,0,8, 0x0028,0x01c2  },    // 59 前门未关报警             
    { 0, 336  , 0x143A52+0x10+0x116E80,   0x400,1,0x100, 0x143A52+0x410+0x116E80,0,8, 0x0028,0x01c2  },    // 60 中门未关报警            
    { 0, 336  , 0x143A52+0x10+0x11B8E0,   0x400,1,0x100, 0x143A52+0x410+0x11B8E0,0,8, 0x0028,0x01c2  },    // 61 报警备用1 
    { 0, 336  , 0x143A52+0x10+0x120340,   0x400,1,0x100, 0x143A52+0x410+0x120340,0,8, 0x0028,0x01c2  },    // 62 报警备用2 
    { 0, 336  , 0x143A52+0x10+0x124DA0,   0x400,1,0x100, 0x143A52+0x410+0x124DA0,0,8, 0x0028,0x01c2  },    // 63 报警备用3 
    { 0, 336  , 0x143A52+0x10+0x129800,   0x400,1,0x100, 0x143A52+0x410+0x129800,0,8, 0x0028,0x01c2  },    // 64 报警备用4  
    { 0, 336  , 0x143A52+0x10+0x12E260,   0x400,1,0x100, 0x143A52+0x410+0x12E260,0,8, 0x0028,0x01c2  },    // 65 报警备用5
    { 0, 336  , 0x143A52+0x10+0x132CC0,   0x400,1,0x100, 0x143A52+0x410+0x132CC0,0,8, 0x0028,0x01c2  },    // 66 报警备用6
    { 0, 336  , 0x143A52+0x10+0x137720,   0x400,1,0x100, 0x143A52+0x410+0x137720,0,8, 0x0028,0x01c2  },    // 67 仪表负载故障报警
    { 0, 336  , 0x143A52+0x10+0x13C180,   0x400,1,0x100, 0x143A52+0x410+0x13C180,0,8, 0x0028,0x01c2  },    // 68 仪表传感器故障报警 
    { 0, 336  , 0x143A52+0x10+0x140BE0,   0x400,1,0x100, 0x143A52+0x410+0x140BE0,0,8, 0x0028,0x01c2  },    // 69 前驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x145640,   0x400,1,0x100, 0x143A52+0x410+0x145640,0,8, 0x0028,0x01c2  },    // 70 前驱动传感器故障报警
    { 0, 336  , 0x143A52+0x10+0x14A0A0,   0x400,1,0x100, 0x143A52+0x410+0x14A0A0,0,8, 0x0028,0x01c2  },    // 71 后驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x14EB00,   0x400,1,0x100, 0x143A52+0x410+0x14EB00,0,8, 0x0028,0x01c2  },    // 72 后驱动传感器故障报警
    { 0, 336  , 0x143A52+0x10+0x153560,   0x400,1,0x100, 0x143A52+0x410+0x153560,0,8, 0x0028,0x01c2  },    // 73 中驱动负载故障报警 
    { 0, 336  , 0x143A52+0x10+0x157FC0,   0x400,1,0x100, 0x143A52+0x410+0x157FC0,0,8, 0x0028,0x01c2  },    // 74 中驱动传感器故障报警               
    { 0, 336  , 0x143A52+0x10+0x15CA20,   0x400,1,0x100, 0x143A52+0x410+0x15CA20,0,8, 0x0028,0x01c2  },    // 75 顶驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x161480,   0x400,1,0x100, 0x143A52+0x410+0x161480,0,8, 0x0028,0x01c2  },    // 76 顶驱动传感器故障报警
    { 0, 336  , 0x143A52+0x10+0x165EE0,   0x400,1,0x100, 0x143A52+0x410+0x165EE0,0,8, 0x0028,0x01c2  },    // 77 配电负载故障报警
    { 0, 336  , 0x143A52+0x10+0x16A940,   0x400,1,0x100, 0x143A52+0x410+0x16A940,0,8, 0x0028,0x01c2  },    // 78 配电保险丝故障报警
    { 0, 336  , 0x143A52+0x10+0x16F3A0,   0x400,1,0x100, 0x143A52+0x410+0x16F3A0,0,8, 0x0028,0x01c2  },    // 79 备用驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x173E00,   0x400,1,0x100, 0x143A52+0x410+0x173E00,0,8, 0x0028,0x01c2  },    // 80 备用驱动传感器故障报警   
                                                            
    
    { 0,286 ,   0x143A52+0x10+0x178860,   0x400,1,0x100, 0x143A52+0x410+0x178860,0,8, 0x0028,0x01c2  },    // 81  祝您一路平安      
    { 0, 336  , 0x143A52+0x10+0x17D2C0,   0x400,1,0x100, 0x143A52+0x410+0x17D2C0,0,8, 0x0028,0x01c2  },    // 82  无前驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x181D20,   0x400,1,0x100, 0x143A52+0x410+0x181D20,0,8, 0x0028,0x01c2  },    // 83  无后驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x186780,   0x400,1,0x100, 0x143A52+0x410+0x186780,0,8, 0x0028,0x01c2  },    // 84  无中驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x18B1E0,   0x400,1,0x100, 0x143A52+0x410+0x18B1E0,0,8, 0x0028,0x01c2  },    // 85  无顶驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x18FC40,   0x400,1,0x100, 0x143A52+0x410+0x18FC40,0,8, 0x0028,0x01c2  },    // 86  无配电模块报警     
    { 0, 336  , 0x143A52+0x10+0x1946A0,   0x400,1,0x100, 0x143A52+0x410+0x1946A0,0,8, 0x0028,0x01c2  },    // 87  E C U通信故障                     
    { 0, 336  , 0x143A52+0x10+0x199100,   0x400,1,0x100, 0x143A52+0x410+0x199100,0,8, 0x0028,0x01c2  },    // 7  备用模块1报警     
    { 0, 336  , 0x143A52+0x10+0x19DB60,   0x400,1,0x100, 0x143A52+0x410+0x19DB60,0,8, 0x0028,0x01c2  },    // 8  备用模块2报警 
    { 0, 336  , 0x143A52+0x10+0x1A25C0,   0x400,1,0x100, 0x143A52+0x410+0x1A25C0,0,8, 0x0028,0x01c2  },    // 9  备用模块3报警     
    { 0, 336  , 0x143A52+0x10+0x1A7020,   0x400,1,0x100, 0x143A52+0x410+0x1A7020,0,8, 0x0028,0x01c2  },    // 10 备用模块4报警     
    { 0, 336  , 0x143A52+0x10+0x1ABA80,   0x400,1,0x100, 0x143A52+0x410+0x1ABA80,0,8, 0x0028,0x01c2  },    // 11 发动机仓火警指示灯
    { 0, 336  , 0x143A52+0x10+0x1B04E0,   0x400,1,0x100, 0x143A52+0x410+0x1B04E0,0,8, 0x0028,0x01c2  },    // 12 蹄片报警指示灯     
    { 0, 336  , 0x143A52+0x10+0x1B4F40,   0x400,1,0x100, 0x143A52+0x410+0x1B4F40,0,8, 0x0028,0x01c2  },    // 13 发动机充电指示   
    { 0, 336  , 0x143A52+0x10+0x1B99A0,   0x400,1,0x100, 0x143A52+0x410+0x1B99A0,0,8, 0x0028,0x01c2  },    // 14 缓速器工作指示   
    { 0, 336  , 0x143A52+0x10+0x1BE400,   0x400,1,0x100, 0x143A52+0x410+0x1BE400,0,8, 0x0028,0x01c2  },    // 15 刹车灯指示   
    { 0, 336  , 0x143A52+0x10+0x1C2E60,   0x400,1,0x100, 0x143A52+0x410+0x1C2E60,0,8, 0x0028,0x01c2  },    // 16 变速箱故障指示 
    { 0, 336  , 0x143A52+0x10+0x1C78C0,   0x400,1,0x100, 0x143A52+0x410+0x1C78C0,0,8, 0x0028,0x01c2  },    // 17 位置灯指示 
    { 0, 336  , 0x143A52+0x10+0x1CC320,   0x400,1,0x100, 0x143A52+0x410+0x1CC320,0,8, 0x0028,0x01c2  },    // 18 空档指示 
    { 0, 336  , 0x143A52+0x10+0x1D0D80,   0x400,1,0x100, 0x143A52+0x410+0x1D0D80,0,8, 0x0028,0x01c2  },    // 19 前进档提示 
    { 0, 336  , 0x143A52+0x10+0x1D57E0,   0x400,1,0x100, 0x143A52+0x410+0x1D57E0,0,8, 0x0028,0x01c2  },    // 20 倒档提示     
    { 0, 336  , 0x143A52+0x10+0x1DA240,   0x400,1,0x100, 0x143A52+0x410+0x1DA240,0,8, 0x0028,0x01c2  },    // 21 消音状态关指示  
    { 0, 336  , 0x143A52+0x10+0x1DECA0,   0x400,1,0x100, 0x143A52+0x410+0x1DECA0,0,8, 0x0028,0x01c2  },    // 22 消音状态开指示   
    { 0, 336  , 0x143A52+0x10+0x1E3700,   0x400,1,0x100, 0x143A52+0x410+0x1E3700,0,8, 0x0028,0x01c2  },    // 23 门应急报警指示
    { 0, 336  , 0x143A52+0x10+0x1E8160,   0x400,1,0x100, 0x143A52+0x410+0x1E8160,0,8, 0x0028,0x01c2  },    // 24 干燥器指示   
    { 0, 336  , 0x143A52+0x10+0x1ECBC0,   0x400,1,0x100, 0x143A52+0x410+0x1ECBC0,0,8, 0x0028,0x01c2  },    // 25 发动机故障指示灯     
    { 0, 336  , 0x143A52+0x10+0x1F1620,   0x400,1,0x100, 0x143A52+0x410+0x1F1620,0,8, 0x0028,0x01c2  },    // 26 空滤报警指示  
    { 0, 336  , 0x143A52+0x10+0x1F6080,   0x400,1,0x100, 0x143A52+0x410+0x1F6080,0,8, 0x0028,0x01c2  },    // 27 气压报警   
    { 0, 336  , 0x143A52+0x10+0x1FAAE0,   0x400,1,0x100, 0x143A52+0x410+0x1FAAE0,0,8, 0x0028,0x01c2  },    // 28 ASR故障指示           
    { 0, 336  , 0x143A52+0x10+0x1FF540,   0x400,1,0x100, 0x143A52+0x410+0x1FF540,0,8, 0x0028,0x01c2  },    // 29 尿素液位低  
    { 0, 336  , 0x143A52+0x10+0x203FA0,   0x400,1,0x100, 0x143A52+0x410+0x203FA0,0,8, 0x0028,0x01c2  },    // 30 左前、后蹄片报警    
    { 0, 336  , 0x143A52+0x10+0x208A00,   0x400,1,0x100, 0x143A52+0x410+0x208A00,0,8, 0x0028,0x01c2  },    // 31 右前、后蹄片报警   
    { 0, 336  , 0x143A52+0x10+0x20D460,   0x400,1,0x100, 0x143A52+0x410+0x20D460,0,8, 0x0028,0x01c2  },    // 32 OBD MIL指示灯 
    { 0, 336  , 0x143A52+0x10+0x211EC0,   0x400,1,0x100, 0x143A52+0x410+0x211EC0,0,8, 0x0028,0x01c2  },    // 33 水位报警   
    { 0, 336  , 0x143A52+0x10+0x216920,   0x400,1,0x100, 0x143A52+0x410+0x216920,0,8, 0x0028,0x01c2  },    // 34 清里程小计指示  
    { 0, 336  , 0x143A52+0x10+0x21B380,   0x400,1,0x100, 0x143A52+0x410+0x21B380,0,8, 0x0028,0x01c2  },    // 35 总电源指示       
    { 0, 336  , 0x143A52+0x10+0x21FDE0,   0x400,1,0x100, 0x143A52+0x410+0x21FDE0,0,8, 0x0028,0x01c2  },    // 36 轻微故障指示灯     
    { 0, 336  , 0x143A52+0x10+0x224840,   0x400,1,0x100, 0x143A52+0x410+0x224840,0,8, 0x0028,0x01c2  },    // 37 近光灯指示   
    { 0, 336  , 0x143A52+0x10+0x2292A0,   0x400,1,0x100, 0x143A52+0x410+0x2292A0,0,8, 0x0028,0x01c2  },    // 38 远光灯指示 
    { 0, 336  , 0x143A52+0x10+0x22DD00,   0x400,1,0x100, 0x143A52+0x410+0x22DD00,0,8, 0x0028,0x01c2  },    // 39 左转向灯指示 
    { 0, 336  , 0x143A52+0x10+0x232760,   0x400,1,0x100, 0x143A52+0x410+0x232760,0,8, 0x0028,0x01c2  },    // 40 水温报警 
    { 0, 336  , 0x143A52+0x10+0x2371C0,   0x400,1,0x100, 0x143A52+0x410+0x2371C0,0,8, 0x0028,0x01c2  },    // 41 驻车符号指示
    { 0, 336  , 0x143A52+0x10+0x23BC20,   0x400,1,0x100, 0x143A52+0x410+0x23BC20,0,8, 0x0028,0x01c2  },    // 42 发动机预热指示
    { 0, 336  , 0x143A52+0x10+0x240680,   0x400,1,0x100, 0x143A52+0x410+0x240680,0,8, 0x0028,0x01c2  },    // 43 发动机仓门开指示
    { 0, 336  , 0x143A52+0x10+0x2450E0,   0x400,1,0x100, 0x143A52+0x410+0x2450E0,0,8, 0x0028,0x01c2  },    // 44 发动机MIL指示灯                                    
    { 0, 336  , 0x143A52+0x10+0x249B40,   0x400,1,0x100, 0x143A52+0x410+0x249B40,0,8, 0x0028,0x01c2  },    // 45 ABS故障指示
    { 0, 336  , 0x143A52+0x10+0x24E5A0,   0x400,1,0x100, 0x143A52+0x410+0x24E5A0,0,8, 0x0028,0x01c2  },    // 46 油量报警指示
    { 0, 336  , 0x143A52+0x10+0x253000,   0x400,1,0x100, 0x143A52+0x410+0x253000,0,8, 0x0028,0x01c2  },    // 47 右转向灯符号片  
    { 0, 336  , 0x143A52+0x10+0x257A60,   0x400,1,0x100, 0x143A52+0x410+0x257A60,0,8, 0x0028,0x01c2  },    // 48 后雾灯符号片                                                                                                                        
    { 0, 336  , 0x143A52+0x10+0x0E3C60,   0x400,1,0x100, 0x143A52+0x410+0x0E3C60,0,8, 0x0028,0x01c2  },    // 49 前雾灯符号片
    { 0, 336  , 0x143A52+0x10+0x0E86C0,   0x400,1,0x100, 0x143A52+0x410+0x0E86C0,0,8, 0x0028,0x01c2  },    // 50 二级故障指示灯
    { 0, 336  , 0x143A52+0x10+0x0ED120,   0x400,1,0x100, 0x143A52+0x410+0x0ED120,0,8, 0x0028,0x01c2  },    // 51 左边柱状报警       
    { 0, 336  , 0x143A52+0x10+0x0F1B80,   0x400,1,0x100, 0x143A52+0x410+0x0F1B80,0,8, 0x0028,0x01c2  },    // 52 右边柱状报警       
    { 0, 336  , 0x143A52+0x10+0x0F65E0,   0x400,1,0x100, 0x143A52+0x410+0x0F65E0,0,8, 0x0028,0x01c2  },    // 53 前门开            
    { 0, 336  , 0x143A52+0x10+0x0FB040,   0x400,1,0x100, 0x143A52+0x410+0x0FB040,0,8, 0x0028,0x01c2  },    // 54 中门开            
    { 0, 336  , 0x143A52+0x10+0x0FFAA0,   0x400,1,0x100, 0x143A52+0x410+0x0FFAA0,0,8, 0x0028,0x01c2  },    // 55 车速报警灯        
    { 0, 336  , 0x143A52+0x10+0x104500,   0x400,1,0x100, 0x143A52+0x410+0x104500,0,8, 0x0028,0x01c2  },    // 56 转速报警灯         
    { 0, 336  , 0x143A52+0x10+0x108F60,   0x400,1,0x100, 0x143A52+0x410+0x108F60,0,8, 0x0028,0x01c2  },    // 57 前气压报警             
    { 0, 336  , 0x143A52+0x10+0x10D9C0,   0x400,1,0x100, 0x143A52+0x410+0x10D9C0,0,8, 0x0028,0x01c2  },    // 58 后气压报警             
    { 0, 336  , 0x143A52+0x10+0x112420,   0x400,1,0x100, 0x143A52+0x410+0x112420,0,8, 0x0028,0x01c2  },    // 59 前门未关报警             
    { 0, 336  , 0x143A52+0x10+0x116E80,   0x400,1,0x100, 0x143A52+0x410+0x116E80,0,8, 0x0028,0x01c2  },    // 60 中门未关报警            
    { 0, 336  , 0x143A52+0x10+0x11B8E0,   0x400,1,0x100, 0x143A52+0x410+0x11B8E0,0,8, 0x0028,0x01c2  },    // 61 报警备用1 
    { 0, 336  , 0x143A52+0x10+0x120340,   0x400,1,0x100, 0x143A52+0x410+0x120340,0,8, 0x0028,0x01c2  },    // 62 报警备用2 
    { 0, 336  , 0x143A52+0x10+0x124DA0,   0x400,1,0x100, 0x143A52+0x410+0x124DA0,0,8, 0x0028,0x01c2  },    // 63 报警备用3 
    { 0, 336  , 0x143A52+0x10+0x129800,   0x400,1,0x100, 0x143A52+0x410+0x129800,0,8, 0x0028,0x01c2  },    // 64 报警备用4  
    { 0, 336  , 0x143A52+0x10+0x12E260,   0x400,1,0x100, 0x143A52+0x410+0x12E260,0,8, 0x0028,0x01c2  },    // 65 报警备用5
    { 0, 336  , 0x143A52+0x10+0x132CC0,   0x400,1,0x100, 0x143A52+0x410+0x132CC0,0,8, 0x0028,0x01c2  },    // 66 报警备用6
    { 0, 336  , 0x143A52+0x10+0x137720,   0x400,1,0x100, 0x143A52+0x410+0x137720,0,8, 0x0028,0x01c2  },    // 67 仪表负载故障报警
    { 0, 336  , 0x143A52+0x10+0x13C180,   0x400,1,0x100, 0x143A52+0x410+0x13C180,0,8, 0x0028,0x01c2  },    // 68 仪表传感器故障报警 
    { 0, 336  , 0x143A52+0x10+0x140BE0,   0x400,1,0x100, 0x143A52+0x410+0x140BE0,0,8, 0x0028,0x01c2  },    // 69 前驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x145640,   0x400,1,0x100, 0x143A52+0x410+0x145640,0,8, 0x0028,0x01c2  },    // 70 前驱动传感器故障报警
    { 0, 336  , 0x143A52+0x10+0x14A0A0,   0x400,1,0x100, 0x143A52+0x410+0x14A0A0,0,8, 0x0028,0x01c2  },    // 71 后驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x14EB00,   0x400,1,0x100, 0x143A52+0x410+0x14EB00,0,8, 0x0028,0x01c2  },    // 72 后驱动传感器故障报警
    { 0, 336  , 0x143A52+0x10+0x153560,   0x400,1,0x100, 0x143A52+0x410+0x153560,0,8, 0x0028,0x01c2  },    // 73 中驱动负载故障报警 
    { 0, 336  , 0x143A52+0x10+0x157FC0,   0x400,1,0x100, 0x143A52+0x410+0x157FC0,0,8, 0x0028,0x01c2  },    // 74 中驱动传感器故障报警               
    { 0, 336  , 0x143A52+0x10+0x15CA20,   0x400,1,0x100, 0x143A52+0x410+0x15CA20,0,8, 0x0028,0x01c2  },    // 75 顶驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x161480,   0x400,1,0x100, 0x143A52+0x410+0x161480,0,8, 0x0028,0x01c2  },    // 76 顶驱动传感器故障报警
    { 0, 336  , 0x143A52+0x10+0x165EE0,   0x400,1,0x100, 0x143A52+0x410+0x165EE0,0,8, 0x0028,0x01c2  },    // 77 配电负载故障报警
    { 0, 336  , 0x143A52+0x10+0x16A940,   0x400,1,0x100, 0x143A52+0x410+0x16A940,0,8, 0x0028,0x01c2  },    // 78 配电保险丝故障报警
    { 0, 336  , 0x143A52+0x10+0x16F3A0,   0x400,1,0x100, 0x143A52+0x410+0x16F3A0,0,8, 0x0028,0x01c2  },    // 79 备用驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x173E00,   0x400,1,0x100, 0x143A52+0x410+0x173E00,0,8, 0x0028,0x01c2  },    // 80 备用驱动传感器故障报警   
                                                            
        
    { 0,286 ,   0x143A52+0x10+0x178860,   0x400,1,0x100, 0x143A52+0x410+0x178860,0,8, 0x0028,0x01c2  },    // 81  祝您一路平安      
    { 0, 336  , 0x143A52+0x10+0x17D2C0,   0x400,1,0x100, 0x143A52+0x410+0x17D2C0,0,8, 0x0028,0x01c2  },    // 82  无前驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x181D20,   0x400,1,0x100, 0x143A52+0x410+0x181D20,0,8, 0x0028,0x01c2  },    // 83  无后驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x186780,   0x400,1,0x100, 0x143A52+0x410+0x186780,0,8, 0x0028,0x01c2  },    // 84  无中驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x18B1E0,   0x400,1,0x100, 0x143A52+0x410+0x18B1E0,0,8, 0x0028,0x01c2  },    // 85  无顶驱动模块报警   
    { 0, 336  , 0x143A52+0x10+0x18FC40,   0x400,1,0x100, 0x143A52+0x410+0x18FC40,0,8, 0x0028,0x01c2  },    // 86  无配电模块报警     
    { 0, 336  , 0x143A52+0x10+0x1946A0,   0x400,1,0x100, 0x143A52+0x410+0x1946A0,0,8, 0x0028,0x01c2  },    // 87  E C U通信故障                     
    { 0, 336  , 0x143A52+0x10+0x199100,   0x400,1,0x100, 0x143A52+0x410+0x199100,0,8, 0x0028,0x01c2  },    // 7  备用模块1报警     
    { 0, 336  , 0x143A52+0x10+0x19DB60,   0x400,1,0x100, 0x143A52+0x410+0x19DB60,0,8, 0x0028,0x01c2  },    // 8  备用模块2报警 
    { 0, 336  , 0x143A52+0x10+0x1A25C0,   0x400,1,0x100, 0x143A52+0x410+0x1A25C0,0,8, 0x0028,0x01c2  },    // 9  备用模块3报警     
    { 0, 336  , 0x143A52+0x10+0x1A7020,   0x400,1,0x100, 0x143A52+0x410+0x1A7020,0,8, 0x0028,0x01c2  },    // 10 备用模块4报警     
    { 0, 336  , 0x143A52+0x10+0x1ABA80,   0x400,1,0x100, 0x143A52+0x410+0x1ABA80,0,8, 0x0028,0x01c2  },    // 11 发动机仓火警指示灯
    { 0, 336  , 0x143A52+0x10+0x1B04E0,   0x400,1,0x100, 0x143A52+0x410+0x1B04E0,0,8, 0x0028,0x01c2  },    // 12 蹄片报警指示灯     
    { 0, 336  , 0x143A52+0x10+0x1B4F40,   0x400,1,0x100, 0x143A52+0x410+0x1B4F40,0,8, 0x0028,0x01c2  },    // 13 发动机充电指示   
    { 0, 336  , 0x143A52+0x10+0x1B99A0,   0x400,1,0x100, 0x143A52+0x410+0x1B99A0,0,8, 0x0028,0x01c2  },    // 14 缓速器工作指示   
    { 0, 336  , 0x143A52+0x10+0x1BE400,   0x400,1,0x100, 0x143A52+0x410+0x1BE400,0,8, 0x0028,0x01c2  },    // 15 刹车灯指示   
    { 0, 336  , 0x143A52+0x10+0x1C2E60,   0x400,1,0x100, 0x143A52+0x410+0x1C2E60,0,8, 0x0028,0x01c2  },    // 16 变速箱故障指示 
    { 0, 336  , 0x143A52+0x10+0x1C78C0,   0x400,1,0x100, 0x143A52+0x410+0x1C78C0,0,8, 0x0028,0x01c2  },    // 17 位置灯指示 
    { 0, 336  , 0x143A52+0x10+0x1CC320,   0x400,1,0x100, 0x143A52+0x410+0x1CC320,0,8, 0x0028,0x01c2  },    // 18 空档指示 
    { 0, 336  , 0x143A52+0x10+0x1D0D80,   0x400,1,0x100, 0x143A52+0x410+0x1D0D80,0,8, 0x0028,0x01c2  },    // 19 前进档提示 
    { 0, 336  , 0x143A52+0x10+0x1D57E0,   0x400,1,0x100, 0x143A52+0x410+0x1D57E0,0,8, 0x0028,0x01c2  },    // 20 倒档提示     
    { 0, 336  , 0x143A52+0x10+0x1DA240,   0x400,1,0x100, 0x143A52+0x410+0x1DA240,0,8, 0x0028,0x01c2  },    // 21 消音状态关指示  
    { 0, 336  , 0x143A52+0x10+0x1DECA0,   0x400,1,0x100, 0x143A52+0x410+0x1DECA0,0,8, 0x0028,0x01c2  },    // 22 消音状态开指示   
    { 0, 336  , 0x143A52+0x10+0x1E3700,   0x400,1,0x100, 0x143A52+0x410+0x1E3700,0,8, 0x0028,0x01c2  },    // 23 门应急报警指示
    { 0, 336  , 0x143A52+0x10+0x1E8160,   0x400,1,0x100, 0x143A52+0x410+0x1E8160,0,8, 0x0028,0x01c2  },    // 24 干燥器指示   
    { 0, 336  , 0x143A52+0x10+0x1ECBC0,   0x400,1,0x100, 0x143A52+0x410+0x1ECBC0,0,8, 0x0028,0x01c2  },    // 25 发动机故障指示灯     
    { 0, 336  , 0x143A52+0x10+0x1F1620,   0x400,1,0x100, 0x143A52+0x410+0x1F1620,0,8, 0x0028,0x01c2  },    // 26 空滤报警指示  
    { 0, 336  , 0x143A52+0x10+0x1F6080,   0x400,1,0x100, 0x143A52+0x410+0x1F6080,0,8, 0x0028,0x01c2  },    // 27 气压报警   
    { 0, 336  , 0x143A52+0x10+0x1FAAE0,   0x400,1,0x100, 0x143A52+0x410+0x1FAAE0,0,8, 0x0028,0x01c2  },    // 28 ASR故障指示           
    { 0, 336  , 0x143A52+0x10+0x1FF540,   0x400,1,0x100, 0x143A52+0x410+0x1FF540,0,8, 0x0028,0x01c2  },    // 29 尿素液位低  
    { 0, 336  , 0x143A52+0x10+0x203FA0,   0x400,1,0x100, 0x143A52+0x410+0x203FA0,0,8, 0x0028,0x01c2  },    // 30 左前、后蹄片报警    
    { 0, 336  , 0x143A52+0x10+0x208A00,   0x400,1,0x100, 0x143A52+0x410+0x208A00,0,8, 0x0028,0x01c2  },    // 31 右前、后蹄片报警   
    { 0, 336  , 0x143A52+0x10+0x20D460,   0x400,1,0x100, 0x143A52+0x410+0x20D460,0,8, 0x0028,0x01c2  },    // 32 OBD MIL指示灯 
    { 0, 336  , 0x143A52+0x10+0x211EC0,   0x400,1,0x100, 0x143A52+0x410+0x211EC0,0,8, 0x0028,0x01c2  },    // 33 水位报警   
    { 0, 336  , 0x143A52+0x10+0x216920,   0x400,1,0x100, 0x143A52+0x410+0x216920,0,8, 0x0028,0x01c2  },    // 34 清里程小计指示  
    { 0, 336  , 0x143A52+0x10+0x21B380,   0x400,1,0x100, 0x143A52+0x410+0x21B380,0,8, 0x0028,0x01c2  },    // 35 总电源指示       
    { 0, 336  , 0x143A52+0x10+0x21FDE0,   0x400,1,0x100, 0x143A52+0x410+0x21FDE0,0,8, 0x0028,0x01c2  },    // 36 轻微故障指示灯     
    { 0, 336  , 0x143A52+0x10+0x224840,   0x400,1,0x100, 0x143A52+0x410+0x224840,0,8, 0x0028,0x01c2  },    // 37 近光灯指示   
    { 0, 336  , 0x143A52+0x10+0x2292A0,   0x400,1,0x100, 0x143A52+0x410+0x2292A0,0,8, 0x0028,0x01c2  },    // 38 远光灯指示 
    { 0, 336  , 0x143A52+0x10+0x22DD00,   0x400,1,0x100, 0x143A52+0x410+0x22DD00,0,8, 0x0028,0x01c2  },    // 39 左转向灯指示 
    { 0, 336  , 0x143A52+0x10+0x232760,   0x400,1,0x100, 0x143A52+0x410+0x232760,0,8, 0x0028,0x01c2  },    // 40 水温报警 
    { 0, 336  , 0x143A52+0x10+0x2371C0,   0x400,1,0x100, 0x143A52+0x410+0x2371C0,0,8, 0x0028,0x01c2  },    // 41 驻车符号指示
    { 0, 336  , 0x143A52+0x10+0x23BC20,   0x400,1,0x100, 0x143A52+0x410+0x23BC20,0,8, 0x0028,0x01c2  },    // 42 发动机预热指示
    { 0, 336  , 0x143A52+0x10+0x240680,   0x400,1,0x100, 0x143A52+0x410+0x240680,0,8, 0x0028,0x01c2  },    // 43 发动机仓门开指示
    { 0, 336  , 0x143A52+0x10+0x2450E0,   0x400,1,0x100, 0x143A52+0x410+0x2450E0,0,8, 0x0028,0x01c2  },    // 44 发动机MIL指示灯                                    
    { 0, 336  , 0x143A52+0x10+0x249B40,   0x400,1,0x100, 0x143A52+0x410+0x249B40,0,8, 0x0028,0x01c2  },    // 45 ABS故障指示
    { 0, 336  , 0x143A52+0x10+0x24E5A0,   0x400,1,0x100, 0x143A52+0x410+0x24E5A0,0,8, 0x0028,0x01c2  },    // 46 油量报警指示
    { 0, 336  , 0x143A52+0x10+0x253000,   0x400,1,0x100, 0x143A52+0x410+0x253000,0,8, 0x0028,0x01c2  },    // 47 右转向灯符号片  
    { 0, 336  , 0x143A52+0x10+0x257A60,   0x400,1,0x100, 0x143A52+0x410+0x257A60,0,8, 0x0028,0x01c2  },    // 48 后雾灯符号片                                                                                                                        
    { 0, 336  , 0x143A52+0x10+0x0E3C60,   0x400,1,0x100, 0x143A52+0x410+0x0E3C60,0,8, 0x0028,0x01c2  },    // 49 前雾灯符号片
    { 0, 336  , 0x143A52+0x10+0x0E86C0,   0x400,1,0x100, 0x143A52+0x410+0x0E86C0,0,8, 0x0028,0x01c2  },    // 50 二级故障指示灯
    { 0, 336  , 0x143A52+0x10+0x0ED120,   0x400,1,0x100, 0x143A52+0x410+0x0ED120,0,8, 0x0028,0x01c2  },    // 51 左边柱状报警       
    { 0, 336  , 0x143A52+0x10+0x0F1B80,   0x400,1,0x100, 0x143A52+0x410+0x0F1B80,0,8, 0x0028,0x01c2  },    // 52 右边柱状报警       
    { 0, 336  , 0x143A52+0x10+0x0F65E0,   0x400,1,0x100, 0x143A52+0x410+0x0F65E0,0,8, 0x0028,0x01c2  },    // 53 前门开            
    { 0, 336  , 0x143A52+0x10+0x0FB040,   0x400,1,0x100, 0x143A52+0x410+0x0FB040,0,8, 0x0028,0x01c2  },    // 54 中门开            
    { 0, 336  , 0x143A52+0x10+0x0FFAA0,   0x400,1,0x100, 0x143A52+0x410+0x0FFAA0,0,8, 0x0028,0x01c2  },    // 55 车速报警灯        
    { 0, 336  , 0x143A52+0x10+0x104500,   0x400,1,0x100, 0x143A52+0x410+0x104500,0,8, 0x0028,0x01c2  },    // 56 转速报警灯         
    { 0, 336  , 0x143A52+0x10+0x108F60,   0x400,1,0x100, 0x143A52+0x410+0x108F60,0,8, 0x0028,0x01c2  },    // 57 前气压报警             
    { 0, 336  , 0x143A52+0x10+0x10D9C0,   0x400,1,0x100, 0x143A52+0x410+0x10D9C0,0,8, 0x0028,0x01c2  },    // 58 后气压报警             
    { 0, 336  , 0x143A52+0x10+0x112420,   0x400,1,0x100, 0x143A52+0x410+0x112420,0,8, 0x0028,0x01c2  },    // 59 前门未关报警             
    { 0, 336  , 0x143A52+0x10+0x116E80,   0x400,1,0x100, 0x143A52+0x410+0x116E80,0,8, 0x0028,0x01c2  },    // 60 中门未关报警            
    { 0, 336  , 0x143A52+0x10+0x11B8E0,   0x400,1,0x100, 0x143A52+0x410+0x11B8E0,0,8, 0x0028,0x01c2  },    // 61 报警备用1 
    { 0, 336  , 0x143A52+0x10+0x120340,   0x400,1,0x100, 0x143A52+0x410+0x120340,0,8, 0x0028,0x01c2  },    // 62 报警备用2 
    { 0, 336  , 0x143A52+0x10+0x124DA0,   0x400,1,0x100, 0x143A52+0x410+0x124DA0,0,8, 0x0028,0x01c2  },    // 63 报警备用3 
    { 0, 336  , 0x143A52+0x10+0x129800,   0x400,1,0x100, 0x143A52+0x410+0x129800,0,8, 0x0028,0x01c2  },    // 64 报警备用4  
    { 0, 336  , 0x143A52+0x10+0x12E260,   0x400,1,0x100, 0x143A52+0x410+0x12E260,0,8, 0x0028,0x01c2  },    // 65 报警备用5
    { 0, 336  , 0x143A52+0x10+0x132CC0,   0x400,1,0x100, 0x143A52+0x410+0x132CC0,0,8, 0x0028,0x01c2  },    // 66 报警备用6
    { 0, 336  , 0x143A52+0x10+0x137720,   0x400,1,0x100, 0x143A52+0x410+0x137720,0,8, 0x0028,0x01c2  },    // 67 仪表负载故障报警
    { 0, 336  , 0x143A52+0x10+0x13C180,   0x400,1,0x100, 0x143A52+0x410+0x13C180,0,8, 0x0028,0x01c2  },    // 68 仪表传感器故障报警 
    { 0, 336  , 0x143A52+0x10+0x140BE0,   0x400,1,0x100, 0x143A52+0x410+0x140BE0,0,8, 0x0028,0x01c2  },    // 69 前驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x145640,   0x400,1,0x100, 0x143A52+0x410+0x145640,0,8, 0x0028,0x01c2  },    // 70 前驱动传感器故障报警
    { 0, 336  , 0x143A52+0x10+0x14A0A0,   0x400,1,0x100, 0x143A52+0x410+0x14A0A0,0,8, 0x0028,0x01c2  },    // 71 后驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x14EB00,   0x400,1,0x100, 0x143A52+0x410+0x14EB00,0,8, 0x0028,0x01c2  },    // 72 后驱动传感器故障报警
    { 0, 336  , 0x143A52+0x10+0x153560,   0x400,1,0x100, 0x143A52+0x410+0x153560,0,8, 0x0028,0x01c2  },    // 73 中驱动负载故障报警 
    { 0, 336  , 0x143A52+0x10+0x157FC0,   0x400,1,0x100, 0x143A52+0x410+0x157FC0,0,8, 0x0028,0x01c2  },    // 74 中驱动传感器故障报警               
    { 0, 336  , 0x143A52+0x10+0x15CA20,   0x400,1,0x100, 0x143A52+0x410+0x15CA20,0,8, 0x0028,0x01c2  },    // 75 顶驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x161480,   0x400,1,0x100, 0x143A52+0x410+0x161480,0,8, 0x0028,0x01c2  },    // 76 顶驱动传感器故障报警
    { 0, 336  , 0x143A52+0x10+0x165EE0,   0x400,1,0x100, 0x143A52+0x410+0x165EE0,0,8, 0x0028,0x01c2  },    // 77 配电负载故障报警
    { 0, 336  , 0x143A52+0x10+0x16A940,   0x400,1,0x100, 0x143A52+0x410+0x16A940,0,8, 0x0028,0x01c2  },    // 78 配电保险丝故障报警
    { 0, 336  , 0x143A52+0x10+0x16F3A0,   0x400,1,0x100, 0x143A52+0x410+0x16F3A0,0,8, 0x0028,0x01c2  },    // 79 备用驱动负载故障报警
    { 0, 336  , 0x143A52+0x10+0x173E00,   0x400,1,0x100, 0x143A52+0x410+0x173E00,0,8, 0x0028,0x01c2  },    // 80 备用驱动传感器故障报警   
                                                             
    {0, 0,   0xF00000+0x10+0x000000,  0X400,1,0,     0xF00000+0x410+0x000000,9,8 ,0x0085,0x0171},       // 前门未关           178
    {0, 0,   0xF00000+0x10+0x00110D,  0x400,1,0,     0xF00000+0x410+0x00110D,9,8, 0x0085,0x0171},       // 中门未关           179
    {0, 0,   0xF00000+0x10+0x001DDB,  0x400,1,0,     0xF00000+0x410+0x001DDB,9,8, 0x0085,0x0171},       // 前中门未关         180   
    {0, 0,   0xF00000+0x10+0x002D03,  0X400,1,0,     0xF00000+0x410+0x002D03,2,8 ,0x0085,0x0171},       // 倒车无视频信号     181
    {0, 0,   0xF00000+0x10+0x00D4C0,  0x400,1,0,     0xF00000+0x410+0x00D4C0,2,8, 0x0085,0x0171},       // 中门无视频信号     182
    {0, 0,   0xF00000+0x10+0x017BDE,  0x400,1,0,     0xF00000+0x410+0x017BDE,2,8, 0x0085,0x0171},       // 前门无视频信号     183   
    {0, 0,   0xF00000+0x10+0x0222CC,  0X400,1,0,     0xF00000+0x410+0x0222CC,2,8 ,0x0085,0x0171},       // 顶门无视频信号     184
  
    

    
}; 
const     INTERFACE_INFO_STRUCT InterfaceInfo[60]@".__LCDCONFIG_DATA"=
{
  //    图层一               图层二           图层三 v            图层四              图层五             图层六 v              图层七v           图层八              图层九
   {
     0x001f,0x01,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,   //45
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,       // 0 视频界面
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   }, 
   {                                                                                                                         // GAI
 //   0x8000,0x01,0x0000, 0xc019,0x01,0x0000, 0x8000,0x01,0x001b, 0xc000,0x01,0x0005, 0xc001,0x01,0x0011, 0xc00F,0x01,95, 0xc010,0x01,96, 0x001d,0x02,219, 0x0000,0x00,0x0000,
    0x8000,0x00,0x0000, 0x8000,0x00,0x001B, 0x0000,0x01,0x001b, 0x0000,0x01,0x0005, 0x0001,0x01,0x0011, 0x000F,0x01,95, 0x0010,0x01,96, 0x001d,0x02,219, 0x0000,0x00,0x0000, 
    0xc000, 0x02, 15,  0  ,  12 , 2,  0x0e,0x31,0x0f,0x31,0 ,0x01, //24
    0xc002, 0x02, 15,  160  ,4 ,  8,  0x0e,0x00,0x0f,0x31,24,0x00, //32
    0xc004, 0x07, 720, 160  ,4  , 8,  0x0e,0x00,0x0f,0x31,56,0x00, //32 1 主界面   //90 
    0x8006, 0x02, 12,  414,  48,  2,  0x0e,0x00,0x0f,0x31,88,0x00, //96
   },   
   {
     0x8000,0x00,28,  0x0000,0x00,0x0000,  0x0000,0x00,0x0000,  0x0000,0x00,0x0000,  0x0000,0x00,0x0000,  0x0000,0x00,0x0000,  0xc002,0x02,0x001c,/*0x0003,0x01,0x001e,*/ 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //2 菜单
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   },
   {
     0x8000,0x01,0x002e, 0xc00A,0x01,95,  0xc00B,0x01,96,   0xc00C,0x01,97,   0xc00D,0x01,98, 0xc00E,0x01,99, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0xc00e,0x01,315,105,  3,   1,   0x0d,0x00,0x0f,0x31,0x00,0x00,
     0xc00f,0x01,329,402,  2,   1,   0x0d,0x00,0x0f,0x31,0x03,0x00,  //3 故障查询
     0xc010,0x01,442,402,  2,   1,   0x0d,0x00,0x0f,0x31,0x05,0x00, 
     0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
   },                                      //项目选择
   {
     0x8004,0x01,47,  0x0000,0x00,0,  0x0004, 0x01,0x0030, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,  0x0000,0x00,0x0000,0xc031, 0x02,0x0030, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,     //4 系统诊断    
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
   },                                                                                                 
   {                                                                   
     0x8000,0x01,68,    0x0000,0x00,0x0000, 0x000a,0x01,70, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0009,0x01,68,  0xc009,0x01,68,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,500,    120,  1 ,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,  //  
     0x8000,0x00,500,    200,  1,    1, 0x0d,0x00,0x0f,0x31,1,  0x00,  // 
     0x8000,0x00,500,    270,  1,    1, 0x0d,0x00,0x0f,0x31,2,  0x00,  //5 参数设置
     0x8000,0x00,344,    350,  20,    1, 0x0d,0x00,0x0f,0x31,3, 0x00,
     
   },
   {
     0x8000,0x00,83, 0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0011, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0xc012,0x01 ,84,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,140,    120,   1,   1, 0x0d,0x00,0x0f,0x31,0, 0x00,
     0x8000,0x00,140,    205,   1,   1, 0x0d,0x00,0x0f,0x31,1, 0x00,  
     0x8000,0x00,140,    283,   1,   1, 0x0d,0x00,0x0f,0x31,2, 0x00,    //6通道设置
     0x8000,0x00,140,    368,   1,   1, 0x0d,0x00,0x0f,0x31,3, 0x00,
   },
   {
     0x8004,0x01,47,  0x0000,0x00,0,  0x0004, 0x01,0x0030, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,  0x0000,0x00,0x0000,0xc011, 0x01,0x0030, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,     //7 能耗查询    
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
   },
   {
     0x8000,0x01,0x002e, 0xc02c,0x01,95,  0xc02d,0x01,96,   0xc02e,0x01,97,   0xc02f,0x01,98, 0xc030,0x01,99, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0xc00e,0x01,315,105,  3,   1,   0x0d,0x00,0x0f,0x31,0x00,0x00,
     0xc00f,0x01,329,402,  2,   1,   0x0d,0x00,0x0f,0x31,0x03,0x00,  //8 发动机诊断
     0xc010,0x01,442,402,  2,   1,   0x0d,0x00,0x0f,0x31,0x05,0x00, 
     0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  
   },
   {
     0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0xc011,0x01,0,0,10,5, 0x0d,0x00,0x0f,0x31,0, 0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  //9 胎压查询
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   },
   {
     0xC018,0x01,95, 0xc01D,0x02,0, 0xc01b,0x02,0x000, 0xc023,0x02,0x000, 0xc025,0x02,0x000, 0xc027,0x02,0x000, 0xc029,0x02,0x000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0xc00c,0x02,240,105,10,10,0x0d,0x00,0x0f,0x31,0x00,0x00,
     0x8000,0x00,615,105,10,11,0x0d,0x00,0x0f,0x31,110,0x00,    
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  //10 帮助查询
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   },
    
   {
     0xc005,0x01,56, 0x0000,0x00,0x0000, 0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  //11 仪表诊断查询
     0x8000,0x01,70,     85,  1,   13, 0x0d,0x00,0x0f,0x31,0x00,0x00,  
     0x8000,0x01,459,    85,  1,   13, 0x0d,0x00,0x0f,0x31,13,  0x00,  //4 系统诊断  
   },
    {
     0xC006,0x01,59, 0x0000,0x00,0x0000, 0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  //12 前驱诊断查询
     0x8000,0x01,70,     85,  1,   13, 0x0d,0x00,0x0f,0x31,0x00,0x00,  
     0x8000,0x01,459,    85,  1,   13, 0x0d,0x00,0x0f,0x31,13,  0x00,  //4 系统诊断  
   },
      {
     0xC007,0x01,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  //13 后驱诊断查询
     0x8000,0x01,70,     85,  1,   13, 0x0d,0x00,0x0f,0x31,0x00,0x00,  
     0x8000,0x01,459,    85,  1,   13, 0x0d,0x00,0x0f,0x31,13,  0x00,  //4 系统诊断  
   },
    {
     0xC008,0x01,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,     //14 顶驱诊断查询
     0x8000,0x01,70,     85,  1,   13, 0x0d,0x00,0x0f,0x31,0x00,0x00,  
     0x8000,0x01,459,    85,  1,   13, 0x0d,0x00,0x0f,0x31,13,  0x00,  //4 系统诊断 
   },
      {
     0xc009,0x01,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  //15 配电诊断查询
     0x8000,0x01,70,     85,  1,   13, 0x0d,0x00,0x0f,0x31,0x00,0x00,  
     0x8000,0x01,459,    85,  1,   13, 0x0d,0x00,0x0f,0x31,13,  0x00,  //4 系统诊断 
   },
   {
     0xc022,0x01,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  //16 电源管理
     0x8000,0x01,84,     85,  1,   13, 0x0d,0x00,0x0f,0x31,0x00,0x00,  
     0x8000,0x01,475,    85,  1,   13, 0x0d,0x00,0x0f,0x31,13,  0x00,  //4 系统诊断 
   },
   {
    0x8000,0x01,0x002e, 0xc02c,0x01,95,  0xc02d,0x01,96,   0xc02e,0x01,97,   0xc02f,0x01,98, 0xc030,0x01,99, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0xc013,0x01,315,105,  3,   1,   0x0d,0x00,0x0f,0x31,0x00,0x00,
     0xc014,0x01,329,402,  2,   1,   0x0d,0x00,0x0f,0x31,0x03,0x00,  //17 
     0xc015,0x01,442,402,  2,   1,   0x0d,0x00,0x0f,0x31,0x05,0x00,    //
     0xc019,0x0f,100,200,  20,  8,  0x0d,0x00,0x0f,0x31,0x0a,0x00,   
   },
   {
    0x8000,0x01,0x002e, 0x0033,0x01,95,  0x0034,0x01,96,   0x0035,0x01,97,   0x0036,0x01,98, 0x0037,0x01,99, 0x0000,0x00,0x0000,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0xc016,0x01,315,105,  3,   1,   0x0d,0x00,0x0f,0x31,0x00,0x00,
     0xc017,0x01,329,402,  2,   1,   0x0d,0x00,0x0f,0x31,0x03,0x00,  //18 
     0xc018,0x01,442,402,  2,   1,   0x0d,0x00,0x0f,0x31,0x05,0x00, 
     0xc028,0x0f,100,200,  20,  8,  0x0d,0x00,0x0f,0x31,0x0a,0x00,  
   },
   {
     0x8000,0x00,83, 0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0011, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0xc012,0x01 ,84,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,140,    120,   1,   1, 0x0d,0x00,0x0f,0x31,0, 0x00,
     0x8000,0x00,140,    205,   1,   1, 0x0d,0x00,0x0f,0x31,1, 0x00,  
     0x8000,0x00,140,    283,   1,   1, 0x0d,0x00,0x0f,0x31,2, 0x00,    //19画面设置通道设置
     0x8000,0x00,140,    368,   1,   1, 0x0d,0x00,0x0f,0x31,3, 0x00,
   },
   {
     0x8000,0x00,88,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0xc013,0x01,89,0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //20 画面设置图像设置
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },
    {
     0x8000,0x01,3,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //21  画面切换
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },
    {
     0x8000,0x00,2,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //22开机logo
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },
   {
     0xc02b,0x01,5,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0xc012,0x01,260,    460,   10,    1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x0000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x0000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //23
     0x0000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },
   
    {
     0x8000,0x00,7,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //24
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   }, 
   {
     0x8000,0x00,9,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //25
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   }, 
    {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //26
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },
     {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //27
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },
   {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //28
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },
   {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //29
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },  
    {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //30
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },  
      {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //31
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },  
      {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //32
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },  
      {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //33
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },  
    {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //34
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },  
   {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //35
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },
    {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //36
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },  
    {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //37
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },  
    {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //38
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },  
    {
     0x8000,0x00,11,  0x0000,0x00,0x000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000, 0x0000,0x00,0x0000,0x0000,0x00,0,  0x0000,0x00,0x0000, 0x0000,0x00,0x0000,
     0x8000,0x00,260,    126,   30,   1, 0x0d,0x00,0x0f,0x31,0,  0x00,
     0x8000,0x00,260,    210,   30,   1, 0x0d,0x00,0x0f,0x31,30, 0x00,  
     0x8000,0x00,260,    290,   30,   1, 0x0d,0x00,0x0f,0x31,60, 0x00,   //39
     0x8000,0x00,260,    370,   30,   1, 0x0d,0x00,0x0f,0x31,90, 0x00,
   },  

};

/*
#define DASHBOARD_NODE_ID           1
#define FRONT_DRIVER_NODE_ID        2
#define TOP_DRIVER_NODE_ID          3      
#define BACK_DRIVER_NODE_ID         4
#define MIDDLE_DRIVER_NODE_ID       5
#define POWER_MODULE_NODE_ID        6 
*/
const    PIC_LOGIC_STRUCT  PicLogicInfo[630]@".__LCDCONFIG_DATA"=     
{
//MODE    index   lenght bitIndex   l     h         num  addr    picLayerNumber  
  0x01, 1,  1,        1,   0,       0,    100,       12, 5,     0,                                      // 0  #define  STEP_INSIDE_16BIT_TYPE    0x01  //#define  STEP_J1939_TYPE           0x02                                                                                                        
  0x01, 1,  1,        6,   0,       0,    300,       10, 17,    0,                                      // 1 
 //0x02,1,  0,        0,   0,       0,     8,        8, 28,    0,//页索引    单页控件数 总控件数       // 2
 //0x03,1, 0,        0,   0,       0,     0,        8, 30,    0,//光标索引              总控件数      // 3
   0x03, 1, 0,        0,   0,       0,     0,        8, 30,    0,//光标索引              总控件数      // 2 
   0x12,1,  1,    0x0304,   0x0506, 0x0708, 0x090A,  0,  0,    0,   //菜单项配置                       // 3                                                                                                   // 3
  
  0x03,1,  0,        0,   0,       0,     0,        8,  48,    0,//三级菜单  选择                      // 4

  0x02,1,  5,        26,  0,       0,     1,        1,  65,    0,//  6=配电诊断  单页控件数 配电1张    // 8 
 
 // 0x02,1,  1,        53,  0,       0,     1,        3,  56,    0,//  1=仪表诊断  单页控件数 仪表3张    // 5
  0x02,1,  2,        50,  0,       0,     1,        2,  59,    0,//  2=前驱诊断  单页控件数 前驱2张    // 6
  0x02, 1, 3,        50,  0,       0,     1,        2,  61,    0,//  3=后驱诊断  单页控件数 后驱1张    // 7   
  0x02, 1, 4,        50,  0,       0,     1,        2,  63,    0,//  6=顶驱诊断  单页控件数 配电1张    // 8                                                             //  4=顶
 // 0x02,1,  5,        47,  0,       0,     1,        2,  65,    0,//  6=配电诊断  单页控件数 配电1张    // 8 
  0x03, 1, 0,        0,   0,       0,     1,        4,  69,    0,//  参数设置菜单                      // 9  
  
  
  0x06,1,  180     ,145 , 0,       0,     0,        0,  97 ,   0,//故障查询  第一行显示                // a
  0x07,1,  180     ,200 , 0,       0,     0,        0,  97 ,   0,//故障查询  第二行显示                // B
  0x08,1,  180     ,250 , 0,       0,     0,        0,  97 ,   0,//故障查询  第三行显示                // C
  0x09,1,  180     ,305 , 0,       0,     0,        0,  97 ,   0,//故障查询  第四行显示                // D 
  0x0a,1,  180     ,352 , 0,       0,     0,        0,  97 ,   0,//故障查询  第五行显示                // E 
  
  
  0x0b, 1, 190     ,286 , 0,       0,     0,        0,  97 ,   0,//首页故障查询  第一行显示            // F 
  0x0c, 1, 190     ,336 , 0,       0,     0,        0,  97 ,   0,//首页故障查询  第二行显示            //0X10 
  0x03, 1, 0,        0,   0,       0,     0,        4,  48,    0,//三级菜单    图像设置选择            //0x11 
  0x03, 1, 0,        0,   0,       0,     0,        4,  84,    0,//            通道设置选择            //0x12  
  0x03, 1, 0,        0,   0,       0,     0,        4,  89,    0,//            画面设置                //0X13  
  0x05, 1, 2,        0,   0,       0,     0,        2,  75,    0,//项目一图片   项数为  2              //0x14
  0x04, 1, 0,        0,   0,       0,     0,        2,  83,    0,//参数设定底部  项数为 2              //0x15
  0x05, 1, 1,        0,   0,       0,     0,        4,  85,    0,//项目一图片   项数为  2              //0x16 
  0x05, 1, 2,        0,   0,       0,     0,        4,  89,    0,//项目一图片   项数为  2              //0x17
  0x02, 1, 0,        0,   0,       0,     1,        2,  95,    0,//帮助界面  单页控件数 2张            //0x18
  0x10, 1, 0x021b, 0x0213, 0x0001, 0x1002,0x2003, 0x3004,0,    0,//前后车门逻辑                        //0x19
  0x02, 1, 0,        0,   0,       0,     1,        2,  77,    0,//信息显示     项数为  2              //0x1a
                   //长度+开始位
 // 0x11,2, 3,   0, 0x0200, 0x0005,   0x1006, 0x2007,  0x3ffd,    0,                                      //0x1b
                       //起始位   位长度       codekey
 //   {/*0x12345678,*/1,  1,          2,  0x8000, 2, 0,       0         },        //500
 //0x11,2, 1,  7, 0x0200, 0x0005,   0x1008, 0x200a,  0x3ffd,    0,                                      //0x1b  
 0x11,1, 0x11,  0, 0x0100, 0x0005,   0x1008, 0x200a,  100,    100,     
 0x11,2, 0x11,  7, 0x0100, 0x0005,   0x1008, 0x200a,  200,    200, 

 0x11,1, 0x11,  0, 0x0100, 0x0005,   0x1008, 0x200a,  300,    300,     
 0x11,2, 0x11,  7, 0x0100, 0x0005,   0x1008, 0x200a,  400,    0,  
 // 0x11,1, 0x0101,   0x021b, 0x0213, 0x021a,   0x4065, 0x5066,  0x6067,    0x7ffd,            //0x1c  1 ceng 
 // 0x11,1, 0x0103,   0,      0, 0,   0x00A7, 0x10A8,  0x20A9,    0x30AA,                      //0x1d  ffe
 // 0x11,1, 0x0103,   0,      0, 0,   0x40AB, 0x50AC,  0x60AD,    0x70AE,                      //0x1e
  0x03, 1, 0,       0,   0,       0,     0,        4, 181,        0,                         //0x1f  //无视频光标              总控件数      // 3
  0x03, 1, 0,       0,   0,       0,     0,        3, 178,        0,                         //0x20  //门未关 光标索引 
  0x02, 1, 5,        50,  0,       0,     1,        2,  65,    0,//  3=后驱诊断  单页控件数 后驱1张    // 0x21  
  0x02, 1, 9,        26,  0,       0,     1,        1,  67,    0,//  6=顶驱诊断  单页控件数 配电1张    // 0x22  
  0x11,1, 0x11,  0, 0x0100, 0x0005,   0x1008, 0x200a,  500,    300,   //0x23  
  0x11,2, 0x11,  7, 0x0100, 0x0005,   0x1008, 0x200a,  500,    0,  
  0x11,1, 0x11,  0, 0x0100, 0x0005,   0x1008, 0x200a,  500,    300,   //0x25  
  0x11,2, 0x11,  7, 0x0100, 0x0005,   0x1008, 0x200a,  500,    0,  
  0x11,1, 0x11,  0, 0x0100, 0x0005,   0x1008, 0x200a,  500,    300,   //0x27  
  0x11,2, 0x11,  7, 0x0100, 0x0005,   0x1008, 0x200a,  500,    0,  
  0x11,1, 0x11,  0, 0x0100, 0x0005,   0x1008, 0x200a,  500,    300,   //0x29  
  0x11,2, 0x11,  7, 0x0100, 0x0005,   0x1008, 0x200a,  500,    0,      //2a
  0x02,1,  0,        0,  0x0b10,     11,     0,    17,  80,    0,     // 2b         11 16 17 23
  0x06,1,  680     ,145 , 1,       0,     0,        0,  97 ,   0,//故障查询  第一行显示                // 2c
  0x07,1,  680     ,200 , 1,       0,     0,        0,  97 ,   0,//故障查询  第二行显示                // 2d
  0x08,1,  680     ,250 , 1,       0,     0,        0,  97 ,   0,//故障查询  第三行显示                // 2e
  0x09,1,  680     ,305 , 1,       0,     0,        0,  97 ,   0,//故障查询  第四行显示                // 2f
  0x0a,1,  680     ,352 , 1,       0,     0,        0,  97 ,   0,//故障查询  第五行显示                // 30 
  
  0x03,1,  0,        0,   0,       0,     0,        8,  48,    0,//三级菜单  选择                      // 31
  0x12,1,  1,    0x0B0C,   0x0D0E, 0x0F10, 0x1112,  0,  0,    0,   //菜单项配置                       //  32  

  0x06,1,  180     ,145 , 2,       0,     0,        0,  97 ,   0,//故障查询  第一行显示                // 33
  0x07,1,  180     ,200 , 2,       0,     0,        0,  97 ,   0,//故障查询  第二行显示                // 34
  0x08,1,  180     ,250 , 2,       0,     0,        0,  97 ,   0,//故障查询  第三行显示                // 35
  0x09,1,  180     ,305 , 2,       0,     0,        0,  97 ,   0,//故障查询  第四行显示                // 36
  0x0a,1,  180     ,352 , 2,       0,     0,        0,  97 ,   0,//故障查询  第五行显示                // 37   
  
  
};
/*
#define DIS_J1939_TYPE                          0x06
#define DIS_INSIDE_16BIT_TYPE                   0x07
#define DIS_INSIDE_32BIT_TYPE                   0x08
#define DIS_SYS_TIME_TYPE                       0x02
#define DIS_COLUMN_WARM                         0x03
#define DIS_SYS_DAY_TYPE                        0x04
*/

const     OSD_LOGIC_STRUCT   OsdLoicgInfo[585]@".__LCDCONFIG_DATA"= 
{ 
  //mode inputIndex  inputLenght   bitIndex thresholdL,thresholdH, charIndex   disLenght color       szUnit[10]
    0x06, 1,  3,          0,       0x0800,          0,         0,           24,    0x0303,  0x31,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //0
    0x07, 1,  6,          0,         0,          0,         0,           56,    0x0202,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //1
    0x03, 1,  1,          48,        52,         52,        56,          0,          0,  0x30,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //2
    0x03, 1,  2,          80,        84,         84,        88,          0,          0,  0x30,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //3
    
    
    0x02, 1,  0,          0,         0,          0,         0,           128,   0x0800,  0x3d,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //4
    0x04, 1,  0,          0,         0,          0,         0,           176,   0x0800,  0x3d,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //5
    0x08, 1,  1,          0,         0,          0,         0,           88,    0x0503,  0x3f,     0x10,'m','/','h',0x00,0x00,0x00,0x00,0x00,0x00,      //6
    0x07, 1,  28,         0,         0,          0,         0,           97,    0x0602,  0x31,     0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //7
    0x07, 1,  48,         0,         0,          0,         0,           105,   0x0304,  0x3C,     0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //8
    0x06, 1,  61,         0,         0,          0,         0,           118,   0x0603,  0x3C,     'd',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    //9
    
    
    0x08, 1,  2,          0,         0,          0,         0,           137,   0x0603,  0x3A,     'K',0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //a
    0x07, 1,  5,          0,         0,          0,         0,           110,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //b  
    0x09, 1,  1,          0,         0,          0,         0,           0,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //c 
    0x09, 2,  2,          0,         0,          0,         0,           20,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //d 
    0x0a, 1,  4,          0,         0,          0,         0,           0,   0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //e 
    0x0a, 1,  3,          0,         0,          0,         0,           5,  0x0200,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //f 
    0x0a, 1,  5,          0,         0,          0,         0,           3,  0x0200,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //10
    0x0b, 1,  5,        10,         33,          0,         0,           0,  0x0200,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //11
    0x0a, 1,  1,          0,         0,          0,         0,           0,  0x0300,  0x34,     ' ','1','8',0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //12
    0x0a, 1,  6,          0,         0,          0,         0,           0,   0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //13 
    0x0a, 1,  3,          0,         0,          0,         0,           5,  0x0200,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //14 
    0x0a, 1,  7,          0,         0,          0,         0,           3,  0x0200,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //15
    0x0a, 1,  8,          0,         0,          0,         0,           0,   0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //16 
    0x0a, 1,  3,          0,         0,          0,         0,           5,  0x0200,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //17 
    0x0a, 1,  9,          0,         0,          0,         0,           3,  0x0200,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //18

    0x0c, 1,  0x0001,      0,         0,          0,         0,           10,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //19 
    0x0c, 1,  0x0101,      0,         0,          0,         0,           15,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //1a 
    0x0c, 1,  0x0102,      0,         0,          0,         0,           20,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //1b 
    
    0x0c, 1,  0x0001,      1,         0,          0,         0,           30,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //1c 
    0x0c, 1,  0x0101,      1,         0,          0,         0,           35,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //1d
    0x0c, 1,  0x0102,      1,         0,          0,         0,           40,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //1e 
   
    0x0c, 1,  0x0001,      2,         0,          0,         0,           50,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //1f  
    0x0c, 1,  0x0101,      2,         0,          0,         0,           55,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //20
    0x0c, 1,  0x0102,      2,         0,          0,         0,           60,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //21

    0x0c, 1,  0x0001,      3,         0,          0,         0,           70,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //22 
    0x0c, 1,  0x0101,      3,         0,          0,         0,           75,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //23
    0x0c, 1,  0x0102,      3,         0,          0,         0,           80,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //24 
    
    0x0c, 1,  0x0001,      4,         0,          0,         0,           90,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //25
    0x0c, 1,  0x0101,      4,         0,          0,         0,           95,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //26
    0x0c, 1,  0x0102,      4,         0,          0,         0,          100,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //27


    0x0c, 1,  0x0001,      0,         0,          0,         0,           10,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //28 
    0x0c, 1,  0x0201,      0,         0,          0,         0,           15,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //29 
    0x0c, 1,  0x0202,      0,         0,          0,         0,           20,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //30 
    
    0x0c, 1,  0x0001,      1,         0,          0,         0,           30,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //31 
    0x0c, 1,  0x0201,      1,         0,          0,         0,           35,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //32
    0x0c, 1,  0x0202,      1,         0,          0,         0,           40,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //33 
   
    0x0c, 1,  0x0001,      2,         0,          0,         0,           50,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //34  
    0x0c, 1,  0x0201,      2,         0,          0,         0,           55,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //35
    0x0c, 1,  0x0202,      2,         0,          0,         0,           60,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //36

    0x0c, 1,  0x0001,      3,         0,          0,         0,           70,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //37 
    0x0c, 1,  0x0201,      3,         0,          0,         0,           75,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //38
    0x0c, 1,  0x0202,      3,         0,          0,         0,           80,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //39 
    
    0x0c, 1,  0x0001,      4,         0,          0,         0,           90,  0x0300,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //40
    0x0c, 1,  0x0201,      4,         0,          0,         0,           95,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //41
    0x0c, 1,  0x0202,      4,         0,          0,         0,          100,  0x0500,  0x34,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //42


};

         
//1->页  2->光标  3->故障第几页    4->故障总个数   5->故障共几页  6-> 故障总个数  7->  故障共几页   
 const     OSD_LOGIC_STRUCT   OsdLoicgInfo1[585]@".__LCDCONFIG_DATA"= 
{ 
  //mode inputIndex  inputLenght   bitIndex thresholdL,thresholdH, charIndex   disLenght color       szUnit[10]
    0x06, 1,  3,          0,         0,          0,         0,           24,    0x0203,  0x31,     0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //0

};

//#pragma CONST_SEG    DEFAULT
//#pragma CODE_SEG  USER_ROM
const  LCD_INTERFACE Interface[40] = 
{
    {construct0,msgProc0,deconstruct0},          // 1  视频界面
    {construct1,msgProc1,deconstruct1},         // 2    主界面
    {construct2,msgProc2,deconstruct2},         // 3  主级菜单   
    {construct3,msgProc3,deconstruct3},          // 4   故障查询
    {construct4,msgProc4,deconstruct4},          //5  二级菜单
    {construct5,msgProc5,deconstruct5},          //6  参数设置
    {construct6,msgProc6,deconstruct6},          //7  画面设置通道设置
    {construct7,msgProc7,deconstruct7},          //8  二级菜单
    {construct8,msgProc8,deconstruct8},          //9  翻页模式
    {construct9,msgProc9,deconstruct9},          //10 翻页模式
    {construct10,msgProc10,deconstruct10},       //11 翻页模式
    {construct11,msgProc11,deconstruct11},       //12 仪表诊断查询
    {construct12,msgProc12,deconstruct12},       //13 前驱诊断查询
    {construct13,msgProc13,deconstruct13},       //14 后驱诊断查询
    {construct14,msgProc14,deconstruct14},       //15 顶驱诊断查询
    {construct15,msgProc15,deconstruct15},       //16 配电诊断查询
    {construct16,msgProc16,deconstruct16},       //17 电源管理诊断查询
    {construct17,msgProc17,deconstruct17},       //18 多包1诊断查询
    {construct18,msgProc18,deconstruct18},       //19 多包2诊断查询
    {construct19,msgProc19,deconstruct19},       //20 画面设置通道设置
    {construct20,msgProc20,deconstruct20},       //21 画面设置图像设置
    {construct21,msgProc21,deconstruct21},       //22 画面切换
    {construct22,msgProc22,deconstruct22},       //23 开机logo
    {construct23,msgProc23,deconstruct23},       //24 翻页模式
    {construct24,msgProc24,deconstruct24},       //25 翻页模式
    {construct25,msgProc25,deconstruct25},       //26 翻页模式
    {construct26,msgProc26,deconstruct26},       //27 翻页模式
    {construct27,msgProc27,deconstruct27},       //28 翻页模式
    {construct28,msgProc28,deconstruct28},       //29 翻页模式
    {construct29,msgProc29,deconstruct29},       //30 二级菜单
    {construct30,msgProc30,deconstruct30},       //31 二级菜单
    {construct31,msgProc31,deconstruct31},       //32 二级菜单
    {construct32,msgProc32,deconstruct32},       //33 胎压学习
    {construct33,msgProc33,deconstruct33},       //34 翻页模式
    {construct34,msgProc34,deconstruct34},       //35 多包3诊断查询
    {construct35,msgProc35,deconstruct35},       //36 视频监控   第三通道
    {construct36,msgProc36,deconstruct36},       //37 翻页模式
    {construct37,msgProc37,deconstruct37},       //38 翻页模式
    {construct38,msgProc38,deconstruct38},       //39 翻页模式
    {construct39,msgProc39,deconstruct39},       //40 翻页模式

    
};

#define OSD_BUFFER_MAX   45
static UINT16 PicAddrBuffer[9];//nbapo:存放9张图片索引
static UINT32 OsdDataTemp[4][OSD_BUFFER_MAX];
static UINT8  OsdLeddisBuf[3]={0x00,0x00,0x00};
static UINT8  OsdLedStatus[3];

#define  TPMS_SENSOR_NUM  6
#define  TPMS_SENSOR_OVER_TIME 20  
UINT8 TpmsStudyStatus[TPMS_SENSOR_NUM];
UINT8 TpmsTimeCnt[TPMS_SENSOR_NUM];
UINT8 MenuConfig[16];
UINT8 DisBlink1Cnt,DisBlink2Cnt;
UINT8 NewDisplayStatus;
UINT8 OldDisplayStatus;
UINT8 Video_Choose;
UINT8 StartLogoDelay;
UINT8 ExitMenuNum;
UINT16 Power_Current_Valve_St;


/***************************************************************************
函数名：void initDisParameter(void)
***************************************************************************/
void initDisParameter(void)
{
    if(SysConfigData.startLogoTime) 
    {
       NewDisplayStatus = 22;//0x01;
       OldDisplayStatus = 22;//0x01;
    }
     else 
    {
		NewDisplayStatus = 1;//0x01;
		OldDisplayStatus = 1;//0x01;
    }
}

/***************************************************************************
函数名：void displayMain(void)
功能：显示处理
***************************************************************************/
	extern void (*TW8835_I2C_delay)(void);

void displayMain(void)
{
	UINT16 i;
	
	if(ON_LOAD != OLD_ON_KEY)
	{
		if(!OLD_ON_KEY)   //on
		{
#if defined(ZB206B)
			EN_12VCP_ON;
#endif
			BK_LCD_refreshFlag = 1;
			TW88XX_Power(1);
			
			//DelayMs(1600);
			//DelayMs(1600);
			DelayMs(5000);
                        FeedWatchDog();
			DelayMs(5000);///等待TW88XX芯片的系统稳定  160

			TW8835_I2C_delay = I2Cdelay2;

			WaitTW8825SystemStability();

			
			InitCPU();
			InitCore();
			InitSystem(0);
			//视频黑白调下中心频率
			WriteTW88(0xff,0x01);
			WriteTW88(0x29,0x20);
			//BackLightCmd(BackLightOpen); 
			LCDBACKLIGHT_PORT_MUX();
			//LCDBACKLIGHT_DUTY =FTM_PWM_Duty(TFT_LINGHT_FRQ,TftDutyCONST[USR_s_DeviceConfigData.LightLevel]+InsideData[10]);	
			FTM_PWM_init(LCDBACKLIGHT_MODULE, LCDBACKLIGHT_CH, TFT_LINGHT_FRQ, 70);//背光LED初始化
			//对比度
			ContrastCmd(USR_s_DeviceConfigData.PictureCfg[0]);	
			//ContrastCmd(5);	
			//亮度
			BrightnessCmd(USR_s_DeviceConfigData.PictureCfg[1]);
			//BrightnessCmd(10);
			//色度
			HueCmd(USR_s_DeviceConfigData.PictureCfg[2]); 
			//HueCmd(6);
			//清晰度
			SharpnessCmd(USR_s_DeviceConfigData.PictureCfg[3]);
			//SharpnessCmd(5);
			initDisParameter();
			Clear_External_WatchDog();
			TW8835_I2C_delay = I2Cdelay;
			Interface[NewDisplayStatus].construct();
			for(i=0;i<J1939_STORAGE_SIZE;i++)    StorageBuffer[i]=0;
			Power_Current_Valve_St = 0;
			//V_POWER3_CTRL =1;
			POWER_12VV_H;
		} 
		else 
		{
			initDisParameter();
			TW88XX_Power(0);
			BOTTOM_TFT_LIGHT_LED_OFF;
			DelayMs(10);
		}
		OLD_ON_KEY = ON_LOAD;
 	} 
	else 
	{
		if(ON_LOAD)
		{ 
			//uint16 pv =0;
			Clear_External_WatchDog();

			//pv = TftDutyCONST[USR_s_DeviceConfigData.LightLevel]+InsideData[10];
			//if(pv>100) pv=100;
			//LCDBACKLIGHT_DUTY =FTM_PWM_Duty(TFT_LINGHT_FRQ,pv);	
			BOTTOM_TFT_LIGHT_LED_ON;   
			NewDisplayStatus = Interface[OldDisplayStatus].msgProc(&LcdMsg);
			if(OldDisplayStatus != NewDisplayStatus)
			{
				Interface[OldDisplayStatus].deconstruct();
				OldDisplayStatus = NewDisplayStatus;
				Interface[NewDisplayStatus].construct();  
			}  
		}
	}
}

/******************************************************************************************
函数名：disLed(UINT8 *pLedStatus)
功能：显示Led状态。
参数说明：UINT8 *pLedStatus -> LED状态信息
******************************************************************************************/
void disLed(UINT8 *pLedStatus)
{     
	UINT8 i,j;
	UINT8 color,colorTemp;
	UINT8 oldF,newF;
	
	for(i=0;i<3;i++) 
	{
		if(pLedStatus[i] !=OsdLeddisBuf[i]) 
		{
			
		
			for(j=0;j<8;j++) 
			{
				oldF = OsdLeddisBuf[i] & (0x01<<j);
				newF = pLedStatus[i] & (0x01<<j);
				if(oldF!=newF) 
				{
					color =  InterfaceInfo[1].osdWin[0].color;
					colorTemp = (color & 0xf0) | (color >> 4);

		
					if(newF)	WriteColor_StringToAddr(8*i+j,colorTemp,(UINT8*)" ",1,0);
					else     WriteColor_StringToAddr(8*i+j,BG_COLOR_BLACK|CH_COLOR_BLACK,(UINT8*)" ",1,0); 
				}
			}
			
			OsdLeddisBuf[i] =  pLedStatus[i];
		}
	}
}
void DisColumnWarn(OSD_LOGIC_STRUCT * index,UINT8 Status) 
{
    UINT8 backColor;
    UINT16 i;
    if(Status==0) 
         {
          backColor = (index->color)>>4;
          backColor |=((index->color)&0xF0);
          for(i=index->inputLenght;i<index->bitIndex;i++)                                          
          WriteColor_StringToAddr (i,backColor,(UINT8*)" ",1,0);  //透明
          for(i=index->thresholdL;i<index->thresholdH;i++)
          WriteColor_StringToAddr (i,backColor,(UINT8*)" ",1,0);  //透明
          for(i=index->charIndex;i<index->disLenght;i++)
          WriteColor_StringToAddr (i,backColor,(UINT8*)" ",1,0);  //透明
         }
     else 
        {
         backColor = (index->color)<<4;
         backColor |=(index->color)&0x0F; 
          for(i=index->inputLenght;i<index->bitIndex;i++)                                          
          WriteColor_StringToAddr (i,backColor,(UINT8*)" ",1,0);  //不透明
          for(i=index->thresholdL;i<index->thresholdH;i++)
          WriteColor_StringToAddr (i,backColor,(UINT8*)" ",1,0);  //不透明
          for(i=index->charIndex;i<index->disLenght;i++)
          WriteColor_StringToAddr (i,backColor,(UINT8*)" ",1,0);  //不透明
          }
}


/******************************************************************************************
函数名：void showChar(UINT8 data,UINT8 dot)
功能：显示8位数据
******************************************************************************************/
void showChar(UINT8 *pBuf,UINT8 data,UINT8 dot)
{
    UINT8 dotTemp = dot;
	dotTemp = dotTemp;
    bit8HexToAscii(pBuf,data);
    //insertDot(pBuf,dot,3);
    DelAsciiInvalidZero(pBuf,3);
}
/******************************************************************************************
函数名void showWord(UINT8 *pBuf,UINT32 data,UINT8 dot) 
功能：显示32位数据
******************************************************************************************/
void showWord(UINT8 *pBuf,UINT32 data,UINT8 dot) 
{
    UINT8 dotTemp = dot;
	dotTemp = dotTemp;
    bit32HexToAscii(pBuf,data);
   // insertDot(pBuf,dot,10);
    DelAsciiInvalidZero(pBuf,10);
}
/******************************************************************************************
函数名：void disInterfacePic(unsigned char interface)
******************************************************************************************/
void disInterfacePic(unsigned char index)
{
	UINT8 i,j;
	UINT16 picIndex;
	UINT16 logicIndex;
	UINT16 logicBufferIndex;
	UINT8  logicLenght;
	PIC_LOGIC_STRUCT  picLogTemp;
	OSD_WIN_STRUCT *osdConfig,osdConfig2; 
	BOTTOM_TFT_LIGHT_LED_OFF;   
	OsdCmd(OsdClose);
	SOsdWinBuffAllClean();
	SpiOsdWinAllOff();
	SOsdHwBuffClean();
	FontOsdWinDisplay(FONT_OSD_ALL_WIN,OFF);     //COMMON_CHARACTER_HEIGHT
	for(i=0;i<4;i++) 
	{  
		osdConfig2 = (InterfaceInfo[index].osdWin[i]);
		osdConfig = &osdConfig2;
		if(osdConfig->attribute & 0x8000) 
		{
			FontOsd_Interface_CharacterHeight_Pixels(osdConfig->charHeight,FONT_OSD_PIXELS_16);///+1是为了小图标能覆盖完整
			FontOsdAplha(i,osdConfig->color>>4,ALPHA_NO_TRANS_VALUE);	                         ///再设定其此界面的透明色
			FontOsdAplha(i,osdConfig->color>>4,ALPHA_TRANS_VALUE);    //过滤掉背光颜色	
			FontOsdWinScreen(i,osdConfig->x,osdConfig->y, osdConfig->w, osdConfig->h);
			FontOsdWinZoom(i,(osdConfig->zoom>>4),osdConfig->zoom&0x0f);
			FontOsdSetOsdRamAddrAttr(i,osdConfig->charIndex);
			switch(osdConfig->initMode) 
			{
				case 1:
				WriteClearStringToAddr(osdConfig->charIndex,BG_COLOR_BLACK|CH_COLOR_BLACK,0x20,osdConfig->w* osdConfig->h, 0);
				//	for(j=0;j< osdConfig->w* osdConfig->h;j++)	
				//	WriteColor_StringToAddr(osdConfig->charIndex+j,BG_COLOR_BLACK|CH_COLOR_BLACK,(UINT8*)" ",1,0);
				break;
				default:
				WriteClearStringToAddr(osdConfig->charIndex,osdConfig->color,0x20,osdConfig->w* osdConfig->h, 0);
				//	for(j=0;j< osdConfig->w* osdConfig->h;j++)	
				//	WriteColor_StringToAddr(osdConfig->charIndex+j,osdConfig->color,(UINT8*)" ",1,0);
				break;
			}
			FontOsdWinDisplay(i,ON);                    
		}
		for(j=0;j<OSD_BUFFER_MAX;j++)
			OsdDataTemp[i][j]=0xffffffff;  	
	} 
	
	for(i=0;i<8;i++) 
	{ 	
		PicAddrBuffer[i] = HSAM_PIC_RESERVE; //初始化图片缓存
		logicIndex = InterfaceInfo[index].picWin[i].attribute;
		logicBufferIndex = logicIndex&0x0fff;
		if(logicIndex&0x8000) 
		{
			if((logicIndex&0x4000)==0)   //不须逻辑算图片索引
			{  
				picIndex = InterfaceInfo[index].picWin[i].picIndex;	
				PicAddrBuffer[i] = picIndex;
				SetPictureInfo(i+1,&PicInfo[picIndex],0,0,0); 
				SpiOsdWinPixelAlpha( i+1, OFF);
			} 
			else 
			{
				logicLenght = InterfaceInfo[index].picWin[i].lenght;
				for(j=0;j<logicLenght;j++) 
				{  
					picLogTemp =  PicLogicInfo[logicBufferIndex];
					logicBufferIndex++;
					if(picLogTemp.mode!=DISPLAY_PIC_PAGE_TYPE)   //还需改进
					{  
						if(1 != picLogTemp.page) 
						{ 
							PicAddrBuffer[i]=0xfffe;
							continue;    //  注意：
						}
					}
					picIndex =    disLogicCalculatePic(&picLogTemp);  
					if(picIndex==HSAM_PIC_CLEAR||picIndex==HSAM_PIC_RESERVE);
					else 
					{
						PicAddrBuffer[i] = picIndex;
						switch(picLogTemp.mode) 
						{
							case 6:
							case 7:
							case 8:
							case 9:
							case 10:
							case 11:
							case 12:

							SetPictureInfo(i+1,&PicInfo[picIndex],picLogTemp.inputIndex,picLogTemp.inputLenght,1);break; //故障查询第一行
							case 0x11:
							case 0x13:
							SetPictureInfo(i+1,&PicInfo[picIndex],picLogTemp.picIndex,picLogTemp.picLayerNumber,1);break; 
							default:SetPictureInfo(i+1,&PicInfo[picIndex],0,0,0);break;
						}
						SpiOsdWinPixelAlpha( i+1, OFF);
					}  
				}
			}  
		} 
	}  
	OsdCmd(OsdOpen);
	SOsdHwBuffWrite2Hw(); 
	BackLightCmd(BackLightOpen);       
	BOTTOM_TFT_LIGHT_LED_ON;   
}

 /******************************************************************************************
 函数名：void doInterfacePiclogic(UINT8 index)
 * @brief			 图片逻辑处理,图片显示
 * @parameter		 index: 	 InterfaceInfo索引
 *				 clear_delay:	   延时时间
 *				 curPage:		 未用保留
 * @return		 None
 * @modify		 
 ******************************************************************************************/
 //UINT8 scanCnt;
void doInterfacePiclogic(UINT8 index,UINT8 clear_delay,UINT8 curPage)   ///UINT8 curPage
{
    UINT8 i,j;
    UINT16 logicIndex;
    UINT16 logicBufferIndex;
    UINT16 picIndex;
    UINT8  logicLenght;
    PIC_LOGIC_STRUCT  picLogTemp;

	for(i=0;i<8;i++) 
	{ 
		logicIndex = InterfaceInfo[index].picWin[i].attribute;//bit15:significant bit, bit14:need logic index
		logicBufferIndex = logicIndex & 0x0fff;		//逻辑索引		 
		if(((logicIndex&0xc000)==0xc000)) //有效*逻辑	
		{ 
			logicLenght = InterfaceInfo[index].picWin[i].lenght;//the lenght of logic process
			for(j=0;j<logicLenght;j++) //nbapo:逻辑处理长度 
			{  
				picLogTemp =  PicLogicInfo[logicBufferIndex];

				logicBufferIndex++;
				picIndex = disLogicCalculatePic(&picLogTemp);//翻页//nbapo:得到图片的索引号

				if(picLogTemp.mode!=DISPLAY_PIC_PAGE_TYPE)   //还需改进//nbapo:非页类型则条件成立
				{  
					/// if(curPage != picLogTemp.page) 
					if(LcdMsg.curPage!= picLogTemp.page)
					{
						// PicAddrBuffer[i]=0xfffe;   //2014 3-17 del afei
						continue; 
					}
				}

				if(picIndex!=HSAM_PIC_RESERVE)  
				{
					if(PicAddrBuffer[i]!=picIndex) //nbapo:有新索引
					{
						//UINT8 mode = picLogTemp.mode;
						//DisableInterrupts;//菜单闪屏问题
						if(picIndex==HSAM_PIC_CLEAR) //nbapo:清除图片
						{ 
							SOsdWinBuffClean(i+1);
							// SpiOsdWinBuffEnable(i+1, OFF);
						}
						else 
						{
							switch(picLogTemp.mode) 
							{
								case 6://nbapo:DISPLAY_FaultInquiry_1
								case 7://nbapo:DISPLAY_FaultInquiry_2
								case 8://nbapo:DISPLAY_FaultInquiry_3
								case 9://nbapo:DISPLAY_FaultInquiry_4
								case 10://nbapo:DISPLAY_FaultInquiry_5
								case 11:
								case 12:
									SetPictureInfo(i+1,&PicInfo[picIndex],picLogTemp.inputIndex,picLogTemp.inputLenght,1);break; //故障查询第一行
								case 0x11:
								case 0x13:
									SetPictureInfo(i+1,&PicInfo[picIndex],picLogTemp.picIndex,picLogTemp.picLayerNumber,1);break; 
								default:SetPictureInfo(i+1,&PicInfo[picIndex],0,0,0);break;
							}
						}
						SpiOsdWinPixelAlpha(i+1, OFF);
						PicAddrBuffer[i]=picIndex;
						//if(LcdMsg.status.b.bit1==0) 
						{
						///*
							//DisableInterrupts;
							switch(clear_delay) 
							{
								case 0x00: SOsdHwBuffWrite_Win(i+1,0);  break;   //不延时
								case 0x01: SOsdHwBuffWrite_Win(i+1,1);  break;   //延时
								case 0x02: SpiOsdWinHWEnable(i+1, OFF); SOsdHwBuffWrite_Win(i+1,0);	SpiOsdWinHWEnable(i+1, ON); break;
								case 0x03: SpiOsdWinHWEnable(i+1, OFF); SOsdHwBuffWrite_Win(i+1,1);	SpiOsdWinHWEnable(i+1, ON); break;
							} 
							//EnableInterrupts;*/
						}

						//EnableInterrupts;
					} 
				}
			}
		}
	}     
}

/******************************************************************************************



******************************************************************************************/
UINT8 *pU8StatusData;
UINT16 disLogicCalculatePic(PIC_LOGIC_STRUCT *index) 
{
	//UINT16 scaleleab[5] = {1,10,100,1000,10000};
	UINT16 inputData;
	UINT16 scale;
	UINT16 picIndex;
	//UINT8  typeIndex;
	// UINT8  page;
	UINT8 i;
	UINT8 dotTemp;
	UINT16 dataIndex;
	UINT8  J1939Type;
	UINT32 dataTemp;
	UINT8 typeData;
	UINT8 startBit;
	UINT8 BitLenght;
	UINT8 DynamicPicNum;
	static UINT8 DynamicCnt; 
	UINT8  byteIndex;
	UINT8  bitIndex;

	switch(index->mode) 
	{
		case  DISPLAY_PIC_GRADIENT_TYPE:     //模拟量//nbapo:柱子
			{
				inputData = (UINT16)getDisParameter((UINT8)index->inputIndex,index->inputLenght,&dotTemp);
				if(inputData>index->thresholdH) 
				{
				picIndex = index->picIndex+index->picNum-1;
				} 
				else if(inputData<index->thresholdL) 
				{
				picIndex = index->picIndex;
				} 
				else
				{   
				scale =  (index->thresholdH - index->thresholdL)/index->picNum;
				if(inputData>index->thresholdL)   inputData -= index->thresholdL;
				else  inputData = 0;
				picIndex =  inputData/scale;
				if(picIndex>(index->picNum-1)) picIndex = index->picIndex+index->picNum-1;
				else   picIndex += index->picIndex;
				}
				break;
			}
		case DISPLAY_PIC_PAGE_TYPE://菜单页索引    //翻页  
			{
				LcdMsg.curPage  =  LcdMsg.pageCnt;
				inputData = LcdMsg.pageCnt; //
				LcdMsg.moduleID = (UINT8)index->inputIndex;    //诊断信息查询 确定模块
				LcdMsg.dispLenght =(UINT8)index->inputLenght; //显示总条数一页固定22条

				if(inputData<1)                         //光标小于1是 返回最好控件号
				{
					LcdMsg.pageCnt = (UINT8)index->picNum;
					LcdMsg.curPage  =  LcdMsg.pageCnt ;
				}
				if(inputData>index->picNum)      //大于总控件数光标返回第一个控件
				{ 
					LcdMsg.pageCnt = 1;
					LcdMsg.curPage = 1;
					if(index->bitIndex)  inputData= index->thresholdL+1;
					else inputData = index->picNum;       //例如有三个控件
				}


				if(inputData>=1) 
				{ 
				inputData = inputData-1;                                                                          
				}                                           
				picIndex= index->picIndex+ inputData;    
				byteIndex = (UINT8)(index->bitIndex>>8);//起始页
				bitIndex  = (UINT8)(index->bitIndex);   //结束页

				if((LcdMsg.pageCnt>=byteIndex)&&(LcdMsg.pageCnt<=bitIndex))   //3 ~7 3
				{
				picIndex= index->picIndex +index->thresholdL-1;

				if(LcdMsg.pageCnt!=LcdMsg.picPage) 
				{
				for(i=0;i<8;i++)PicAddrBuffer[i]=0xfffe;//清空缓存
				LcdMsg.picPage = LcdMsg.pageCnt;  
				SOsdWinBuffAllClean();    //  
				SOsdHwBuffWrite2Hw(); 
				}
				} 
				else 
				{
				if(LcdMsg.pageCnt!=LcdMsg.picPage) 
				{ 
				for(i=1;i<8;i++)PicAddrBuffer[i]=0xfffe;//清空缓存
				LcdMsg.picPage = LcdMsg.pageCnt;
				// BackLightCmd(BackLightOff);
				//  LcdMsg.status.b.bit1 =1;
				SOsdWinBuffAllClean();    //  
				SOsdHwBuffWrite2Hw();  
				}  

				}
				if(index->bitIndex)  //有假翻页
				{ 

				if(LcdMsg.pageCnt>bitIndex) 
				{                              
				picIndex= index->picIndex + index->thresholdL;
				}
				}
				break;   
			}
		case DISPLAY_PIC_CURSOR_TYPE: //光标
			{
				inputData = LcdMsg.cursor;
				if(inputData > index->picNum) 
				{
					LcdMsg.cursor = 1;
					picIndex = index->picIndex;
				} 
				else if(inputData<1) 
				{
					LcdMsg.cursor = (UINT8)index->picNum;
					picIndex = index->picIndex+index->picNum-1;
				} 
				else 
				{
					picIndex = index->picIndex+inputData-1;
				} 
				if(LcdMsg.status.b.disFlag ==CLEAR_PIC_F)  //处理不选中
				{
					picIndex=HSAM_PIC_CLEAR;
				}  
				break;
			}
		case  DISPLAY_PIC_KEY_STATUS_TYPE:       //nbapo:状态输出-首页
			{
				//开关1, 2
				inputData = Key_IndexToValue(index->inputIndex);
				inputData<<=1;
				inputData|= Key_IndexToValue(index->inputLenght);
				//nbapo:低12位为图片索引，高4位图片状态
				if(inputData==(index->bitIndex>>12))       picIndex = index->bitIndex&0x0fff;
				else if(inputData==(index->thresholdL>>12))picIndex = index->thresholdL&0x0fff;
				else if(inputData==(index->thresholdH>>12))picIndex = index->thresholdH&0x0fff;
				else if(inputData==(index->picNum>>12))    picIndex = index->picNum&0x0fff;
				else picIndex = HSAM_PIC_RESERVE;
				break;  
			}
		case DISPLAY_MENU_CONFIG_TYPE:
			if(index->inputIndex>0) 
			{
				inputData = (index->inputIndex-1)*8;
				MenuConfig[inputData]=index->inputLenght>>8;
				MenuConfig[inputData+1]=index->inputLenght&0xff;
				MenuConfig[inputData+2]=index->bitIndex>>8;
				MenuConfig[inputData+3]=index->bitIndex&0xff;
				MenuConfig[inputData+4]=index->thresholdL>>8;
				MenuConfig[inputData+5]=index->thresholdL&0xff;
				MenuConfig[inputData+6]=index->thresholdH>>8;
				MenuConfig[inputData+7]=index->thresholdH&0xff;
			}
			picIndex=HSAM_PIC_RESERVE;   
			break;  
		case  DISPLAY_PIC_STATUS_TYPE:
			{
				typeData = (UINT8)index->inputIndex;
				DynamicPicNum =  (UINT8)(index->inputIndex>>8);
				startBit = (UINT8)index->bitIndex;
				BitLenght= (UINT8)(index->bitIndex>>8);  
				switch(typeData) 
				{
					case 1:  
						{
							dataIndex =  index->inputLenght;                                 //j1939 index
							J1939Type  = J1939WordDataConfig[dataIndex].attribute&0x0f; 
							switch(J1939Type) 
							{
								case J1939_Status_Type :  dataTemp=StorageBuffer[J1939_OFFSET_BYTE+dataIndex]; break;            
								case J1939_Char_Type   :  
												dataTemp=StorageBuffer[J1939_OFFSET_BYTE+dataIndex]; 
												if(J1939WordDataConfig[dataIndex].offset>dataTemp)  dataTemp = 0;
												else dataTemp-=J1939WordDataConfig[dataIndex].offset;
												break;          
								case J1939_Int_Type    :  dataTemp=*(UINT16 *)(&StorageBuffer[J1939_OFFSET_BYTE+2*dataIndex-J1939_STATUS_NUMBER-J1939_CHAR_NUMBER]);break;                
								case J1939_Three_Type  :  dataTemp=*(UINT32 *)(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break; 
								case J1939_Word_Type   :  dataTemp=*(UINT32 *)(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break;                
								default:dataTemp = 0 ;break;
							};
							dataTemp>>=startBit;
							dataTemp&=((0x000001<<BitLenght)-1);
							break;          //j139;
						}
					case 2:  break;               //内部数据          
					case 0x11: pU8StatusData=  DASHBOARD_MODULE_PHYSICAL_KEYS_ADDRESS;  break;   
					case 0x12: pU8StatusData=  FRONT_MODULE_PHYSICAL_KEYS_ADDRESS;      break;    
					case 0x13: pU8StatusData=  BACK_MODULE_PHYSICAL_KEYS_ADDRESS ;      break;    
					case 0x14: pU8StatusData=  MIDDLE_MODULE_PHYSICAL_KEYS_ADDRESS;     break;    
					case 0x15: pU8StatusData=  TOP_MODULE_PHYSICAL_KEYS_ADDRESS;        break;   
					case 0x16: pU8StatusData=  POWER_MODULE_PHYSICAL_KEYS_ADDRESS;      break;     
					case 0x17: pU8StatusData=  POWER_CONTOROL_MODULE_PHYSICAL_KEYS_ADDRESS; break;         
					case 0x18: pU8StatusData=  DASHBOARD_MODULE_VIRTUAL_KEYS_ADDRESS;       break;   
					case 0x19: pU8StatusData=  FRONT_DRIVER_MODULE_SHORT_OPEN_KEYS_ADDRESS; break;   
					case 0x1A: pU8StatusData=  BACK_DRIVER_MODULE_SHORT_OPEN_KEYS_ADDRESS;   break;  
					case 0x1B: pU8StatusData=  MIDDLE_DRIVER_MODULE_SHORT_OPEN_KEYS_ADDRESS; break;  
					case 0x1C: pU8StatusData=  TOP_DRIVER_MODULE_SHORT_OPEN_KEYS_ADDRESS;    break;  
					case 0x1D: pU8StatusData=  POWER_MODULE_SHORT_OPEN_KEYS_ADDRESS;          break; 
					case 0x1E: pU8StatusData=  POWER_CONTOROL_MODULE_SHORT_OPEN_KEYS_ADDRESS; break;           
					case 0x1F: pU8StatusData=  DASHBOARD_MODULE_PHYSICAL_LOAD_ADDRESS;      break;
					case 0x20: pU8StatusData=  FRONT_MODULE_PHYSICAL_LOAD_ADDRESS ;         break;
					case 0x21: pU8StatusData=  BACK_MODULE_PHYSICAL_LOAD_ADDRESS;           break;
					case 0x22: pU8StatusData=  MIDDLE_MODULE_PHYSICAL_LOAD_ADDRESS;         break;
					case 0x23: pU8StatusData=  TOP_MODULE_PHYSICAL_LOAD_ADDRESS;            break;
					case 0x24: pU8StatusData=  POWER_MODULE_PHYSICAL_LOAD_ADDRESS;          break; 
					case 0x25: pU8StatusData=  POWER_CONTOROL_MODULE_PHYSICAL_LOAD_ADDRESS; break; 
					case 0x50: pU8StatusData=  LOAD_STATE_FROM_PIC_ADDRESS;                 break;   //负载逻辑转图片
					default:break;
				}
				if(typeData>0x10) 
				{
					byteIndex=(UINT8)(index->inputLenght/8);       //    40   41  42 43 44 45 46 47 48
					bitIndex= (UINT8)(index->inputLenght%8);       //    b0   b1  b2 b3 b4 b5 b6 b7 b0
					//dataTemp= pU8StatusData[byteIndex];
					if(bitIndex + BitLenght > 8) 
					{ 
						dataTemp = pU8StatusData[byteIndex+1];
						dataTemp <<= 8;
						dataTemp |= pU8StatusData[byteIndex];
					}
					else 
					{
						dataTemp = pU8StatusData[byteIndex];
					}
					dataTemp >>= bitIndex;
					dataTemp &= ((0x00001<<BitLenght)-1);  //nbapo:有效位长 
				}
				if((index->thresholdL >> 12) == dataTemp)
					picIndex =  index->thresholdL & 0x0fff;
				else if((index->thresholdH >> 12) == dataTemp)
					picIndex =  index->thresholdH & 0x0fff;
				else if((index->picNum >> 12) == dataTemp)
					picIndex =  index->picNum & 0x0fff;
				else   picIndex = HSAM_PIC_RESERVE;
				if(picIndex == 0x0ffe)   picIndex = HSAM_PIC_RESERVE;
				if(picIndex == 0x0ffd)   picIndex = HSAM_PIC_CLEAR;   //清掉
				if((picIndex != HSAM_PIC_RESERVE) && (picIndex != HSAM_PIC_CLEAR)) 
				{
					if(DynamicPicNum)   //
					{
						if(D_1S_F) 
						{
							DynamicCnt++; 
							D_1S_F=0;
						}
						picIndex +=(DynamicCnt%DynamicPicNum);  
					}
				} 

				break;  
			}
		case 0x06://故障查询 1    
		case 0x07://故障查询 2
		case 0x08://故障查询 3                   
		case 0x09://故障查询 4   
		case 0x0a://故障查询 5
		case 0x0b://首页故障查询 1 
		case 0x0c://首页故障查询 2
			{
				if(index->mode <= 0x0a)	inputData = LcdMsg.cursor + (index->mode - 6);
				else	inputData = LcdMsg.cursor + (index->mode - 0x0b);//nbapo:首页故障
				
				if(index->bitIndex == 0) 
				{  
					if(inputData >=dis_count)  picIndex = HSAM_PIC_CLEAR;
					else
					{
						picIndex = index->picIndex + dis_content[inputData]; 
					}
				} 
				else if(index->bitIndex == 1) 
				{
					if(inputData >=MultiPgckage_AvailableByte_Num[0])  picIndex = HSAM_PIC_CLEAR;
					else
					{
						picIndex =  index->picIndex + DiagnosePicIndx[inputData]; 
					}
				} 
				else if(index->bitIndex == 2) 
				{ 
					if(inputData >=MultiPgckage_AvailableByte_Num[1])  picIndex = HSAM_PIC_CLEAR;
					else
					{
						picIndex =  index->picIndex + DiagnosePicIndx1[inputData]; 
					}
				} 
				else if(index->bitIndex==3) 
				{ 
					if(inputData >=MultiPgckage_AvailableByte_Num[2])  picIndex = HSAM_PIC_CLEAR;
					else
					{
						picIndex =  index->picIndex + DiagnosePicIndx2[inputData]; 
					}
				} 
				break;
			}
		case   DISPLAY_PIC_TPMS_TYPE:            //胎压学习状态
			{
				typeData = (UINT8)(index->inputIndex&0x07);  //胎压
				pU8StatusData =  DASHBOARD_MODULE_VIRTUAL_KEYS_ADDRESS; 
				byteIndex=(UINT8)(index->inputLenght/8);
				bitIndex= (UINT8)(index->inputLenght%8);
				dataTemp = pU8StatusData[byteIndex];
				dataTemp>>=bitIndex;
				if((dataTemp&0x01)) 
				{
					pU8StatusData[byteIndex] &= (~(1<<bitIndex));//清掉虚拟开关
					if(TpmsStudyStatus[typeData]&0x01)
					TpmsStudyStatus[typeData] |= 0x02;       //  00->无图片    01->请求  11->配对成功 10->配对失败
				}

				if((index->thresholdL>>12)==TpmsStudyStatus[typeData])
				picIndex =  index->thresholdL&0x0fff;
				else if((index->thresholdH>>12)==TpmsStudyStatus[typeData])
				picIndex =  index->thresholdH&0x0fff;
				else if((index->picNum>>12)==TpmsStudyStatus[typeData])
				picIndex =  index->picNum&0x0fff;
				else   picIndex = HSAM_PIC_RESERVE;

				break;
			}	
		default:break;
	}
	return picIndex ;
}
/******************************************************************************************
void dispSysTime(OSD_LOGIC_STRUCT *index) 
******************************************************************************************/
void dispSysTime(OSD_LOGIC_STRUCT * index,UINT8 *disTime) 
{
  UINT8 Time_Display[8];
  UINT8  dispLenght;
  dispLenght =(index->disLenght>>8);
  Time_Display[0] = (disTime[0]>>4)+'0';
  Time_Display[1] = (disTime[0]&0x0f)+'0';
  Time_Display[2] = ':'; 
  Time_Display[3] = (disTime[1]>>4)+'0';
  Time_Display[4] = (disTime[1]&0x0f)+'0';
  Time_Display[5] = ':';
  Time_Display[6] = (disTime[2]>>4)+'0';
  Time_Display[7] = (disTime[2]&0x0f)+'0';
  
  WriteColor_StringToAddr(index->charIndex, index->color,Time_Display,dispLenght,0);
}

//void doDayFromInt(OSD_LOGIC_STRUCT * index,UINT8* bcdDay) 
//{
//  UINT8 Time_Display[3];
//  Time_Display[0] =  (UINT8)(bcdDay[0]);
//  Time_Display[1] =  (UINT8)(bcdDay[1]);
//  Time_Display[2] =  (UINT8)(bcdDay[2]);
//  dispSysDay(index,Time_Display);
//}

void dispLeavingsTime(OSD_LOGIC_STRUCT * index,UINT16 data) 
{
  UINT8 Time_Display[8];
  UINT8  dispLenght,temp;
  dispLenght =(index->disLenght>>8);
  temp = (UINT8)(data/3600);
  Time_Display[0] = (temp/10)+'0';
  Time_Display[1] = (temp%10)+'0';
  Time_Display[2] = ':'; 
  temp = (UINT8)((data%3600)/60);
  Time_Display[3] = (temp/10)+'0';
  Time_Display[4] = (temp%10)+'0';
  Time_Display[5] = ':';
  temp = (UINT8)(data%60);
  Time_Display[6] = (temp/10)+'0';
  Time_Display[7] = (temp%10)+'0';  
  WriteColor_StringToAddr(index->charIndex, index->color,Time_Display,dispLenght,0);
}


void dispSysDay(OSD_LOGIC_STRUCT * index,UINT8 *disDay) 
{
  UINT8 day_Display[10];
  UINT8 dispLenght;
  dispLenght =(index->disLenght>>8);
 // day_Display[0] = '2';
  //day_Display[1] = '0';
  day_Display[0] = (disDay[0]>>4)+'0';
  day_Display[1] = (disDay[0]&0x0f)+'0';
  day_Display[2] = '-'; 
  day_Display[3] = (disDay[1]>>4)+'0';
  day_Display[4] = (disDay[1]&0x0f)+'0';
  day_Display[5] = '-';
  day_Display[6] = (disDay[2]>>4)+'0';
  day_Display[7] = (disDay[2]&0x0f)+'0';  
  WriteColor_StringToAddr(index->charIndex, index->color,day_Display,dispLenght,0);
}
void disSysDistance(OSD_LOGIC_STRUCT * index) 
{
  UINT8  dispTemp[10];
  UINT8  dot;
  UINT16  dispLenght;
  UINT16  StartAddr;
  UINT8  dispStart;
  UINT8  i,j;
  UINT8  *charIndex;
  UINT32 inputData;
  j=0;
    inputData = 10000;
    dot = index->disLenght&0x00ff;                       
    showWord(dispTemp,inputData,dot); 
    if(dot) dispLenght=1;
    else  dispLenght = 0;
    dispLenght = dispLenght + dot;
    dispLenght +=(index->disLenght>>8);
    dispStart = 10- dispLenght;
    charIndex = &dispTemp[dispStart]; 
    StartAddr = index->charIndex;
    WriteColor_StringToAddr(StartAddr, index->color,charIndex,(UINT8)dispLenght,0);
    for(i=0;i<sizeof(index->szUnit);i++) 
    {
     if(index->szUnit[i]!=0)    j++; 
     else  break;
    }
    StartAddr = index->charIndex+dispLenght;
    charIndex =&index->szUnit[0]; 
    WriteColor_StringToAddr(StartAddr, index->color,charIndex,j,0);
}
  

/******************************************************************************************
void disOsdLogicResult(OSD_LOGIC_STRUCT *index,UINT32 dat)
******************************************************************************************/
 /*
    typedef struct
    {
      UINT8    mode;       //逻辑模式mode=1数字 moder = 2字母
      UINT16   page;
      UINT16   inputIndex; 
      UINT16   inputLenght; 
      UINT16   bitIndex;     //高八位为起始位  低八位结束位
      UINT16   thresholdL;   //显示方式 0->十进制显示  1->十六进制显示
      UINT16   thresholdH;
      UINT16   charIndex;   //osd ram 地址
      UINT16   disLenght;   //高八位为整数长度 低八位为小数点长度
      UINT8    color;
      UINT8    szUnit[10]; //单位或其他
    }OSD_LOGIC_STRUCT;
 */
 
/******************************************************************************************
* void disOsdLogicResult(OSD_LOGIC_STRUCT * index,UINT32 dat,UINT16 bitval)
* @brief
* @parameter			index:osd逻辑信息
*						dat:	显示的数据
*						bitval
******************************************************************************************/
void disOsdLogicResult(OSD_LOGIC_STRUCT * index,UINT32 dat,UINT8 bitval) 
{
	UINT8  *charIndex;
	UINT8  dataTemp[20];
	UINT8  disDat[20];
	UINT32 inputData;
	UINT8  dot;
	UINT8  dispLenght;
	UINT8  dispStart;
	UINT8  i;
	UINT8  outType;
	UINT8  Length;

	UINT8 disDotLenght;
	UINT8 disIntegerLenght;
	UINT8 stringLenght;
	UINT8 J1939Type;
	UINT8 typeData;
	UINT8 startBit;
	UINT8 BitLenght;
	UINT16 dataIndex;
	UINT8 byteIndex;
	UINT8 bitIndex;
	
	stringLenght = 0;
	for(i=0;i<sizeof(index->szUnit);i++) 
	{
		if(index->szUnit[i]!=0) stringLenght++; 
		else  break;
	}       
	inputData = dat;
	switch(index->mode) 
	{
		case 0x01:  // 数字显示
			{
		        dot = index->disLenght&0x00ff;                       
		        showWord(dataTemp,inputData,dot); 
		        if(dot) dispLenght=1;
		        else  dispLenght = 0;
		        dispLenght = dispLenght + dot;
		        dispLenght +=(index->disLenght>>8);
		        dispStart = 10- dispLenght;
		        charIndex = &dataTemp[dispStart]; 
		        WriteColor_StringToAddr(index->charIndex, index->color,charIndex,dispLenght,0);
		        WriteColor_StringToAddr(index->charIndex+dispLenght, index->color,index->szUnit,stringLenght,0);
		        break;
			}    
		case DIS_J1939_TYPE:     //0x06
			{
				outType =  (UINT8)(index->thresholdL>>8);
				if(outType==0) //正常显示
				{
					disDotLenght = index->disLenght&0x00ff;
					disIntegerLenght = index->disLenght>>8;
					Length =  builtLcdText(dataTemp,DIS_J1939_TYPE,index->inputIndex,inputData,0);
					Length =  arrangeDispBuffer(dataTemp,disDat,Length, disDotLenght,disIntegerLenght);
					DelAsciiInvalidZeroEx(disDat,Length);
					WriteColor_StringToAddr(index->charIndex,index->color,disDat,Length,0);
					WriteColor_StringToAddr(index->charIndex+Length, index->color,index->szUnit,stringLenght,0);
				}
				if(outType==1) //nbapo:16进制显示
				{
					disIntegerLenght = index->disLenght>>8;
					J1939Type  = J1939WordDataConfig[index->inputIndex].attribute&0x0f; 
					DispHexToAscii(disDat,inputData); //0123456789a
					switch(J1939Type)                 //ff ff ff ff 
					{
						case J1939_Status_Type :  Length = 9;break;            
						case J1939_Char_Type   :  Length = 9;break;          
						case J1939_Int_Type    :  Length = 6;break;                
						case J1939_Three_Type  :  Length = 3;break; 
						case J1939_Word_Type   :  Length = 0;break;                
					};
					WriteColor_StringToAddr(index->charIndex,index->color,&disDat[Length],disIntegerLenght,0);
				}
				if(outType==2) 
				{
					disDotLenght = index->disLenght&0x00ff;
					disIntegerLenght = index->disLenght>>8;
					Length =  builtLcdText(dataTemp,DIS_J1939_TYPE,index->inputIndex,inputData,0);
					Length =  arrangeDispBuffer(dataTemp,disDat,Length, disDotLenght,disIntegerLenght);
					//DelAsciiInvalidZeroEx(disDat,Length);
					WriteColor_StringToAddr(index->charIndex,index->color,disDat,Length,0);
					WriteColor_StringToAddr(index->charIndex+Length, index->color,index->szUnit,stringLenght,0);
				}
				if(outType==3) //nbapo:二进制显示
				{
					disIntegerLenght = index->disLenght>>8;
					Disp2ToAscii(disDat,(unsigned char)inputData);
					//disDat[0]='p'; disDat[1]='k';

					WriteColor_StringToAddr(index->charIndex,index->color,&disDat[8-disIntegerLenght],disIntegerLenght,0);
					WriteColor_StringToAddr(index->charIndex+disIntegerLenght, index->color,index->szUnit,stringLenght,0);
				}
				if(outType==4) 
				{
					dispLeavingsTime(index,dat);   //显示剩余时间  
				}
				if(outType==5) //nbapo:多态
				{
					if(bitval==0) //正常显示
					{
						disDotLenght = index->disLenght&0x00ff;
						disIntegerLenght = index->disLenght>>8;
						Length =  builtLcdText(dataTemp,DIS_J1939_TYPE,index->inputIndex,inputData,0);
						Length =  arrangeDispBuffer(dataTemp,disDat,Length, disDotLenght,disIntegerLenght);
						DelAsciiInvalidZeroEx(disDat,Length);
						WriteColor_StringToAddr(index->charIndex,index->color,disDat,Length,0);
						WriteColor_StringToAddr(index->charIndex+Length, index->color,index->szUnit,stringLenght,0);
					}
					else if(bitval==0x10) // 0
					{
						disDotLenght = index->disLenght&0x00ff;
						disIntegerLenght = index->disLenght>>8;
						Length =  builtLcdText(dataTemp,DIS_J1939_TYPE,index->inputIndex,0,0);
						Length =  arrangeDispBuffer(dataTemp,disDat,Length, disDotLenght,disIntegerLenght);
						DelAsciiInvalidZeroEx(disDat,Length);
						WriteColor_StringToAddr(index->charIndex,index->color,disDat,Length,0);
						WriteColor_StringToAddr(index->charIndex+Length, index->color,index->szUnit,stringLenght,0);
					} 
					else if(bitval==0x08) //full
					{
						disDotLenght = index->disLenght & 0x00ff;
						disIntegerLenght = index->disLenght >> 8;
						Length = disDotLenght + disIntegerLenght;
						disDotLenght = 0;
						if(Length>4) 
						{
							disDotLenght =  Length - 4;
							WriteColor_StringToAddr(index->charIndex,index->color,"       ",disDotLenght,0); 
						}
						WriteColor_StringToAddr(index->charIndex+disDotLenght,index->color,"full",4,0); 
					} 
					else if(bitval==0x18) //-err
					{
						disDotLenght = index->disLenght&0x00ff;
						disIntegerLenght = index->disLenght>>8;
						Length = disDotLenght +  disIntegerLenght;
						disDotLenght = 0;
						if(Length>4) 
						{
							disDotLenght =  Length - 4;
							WriteColor_StringToAddr(index->charIndex,index->color,"       ",disDotLenght,0); 
						}
						WriteColor_StringToAddr(index->charIndex+disDotLenght,index->color,"-err",4,0); 
					} 
					else if(bitval==0x04) //+err
					{
						disDotLenght = index->disLenght&0x00ff;
						disIntegerLenght = index->disLenght>>8;
						Length = disDotLenght +  disIntegerLenght;
						disDotLenght = 0;
						if(Length>4) 
						{
							disDotLenght =  Length - 4;
							WriteColor_StringToAddr(index->charIndex,index->color,"       ",disDotLenght,0); 
						}
						WriteColor_StringToAddr(index->charIndex+disDotLenght,index->color,"+err",4,0); 
					}
					else if((bitval&0x02)==0x02)//显示空
					{
						disDotLenght = index->disLenght&0x00ff;
						disIntegerLenght = index->disLenght>>8;
						Length = disDotLenght +  disIntegerLenght;
						WriteColor_StringToAddr(index->charIndex,index->color,"         ",Length,0); 
					}
				}  
				break;
			}
		case DIS_INSIDE_16BIT_TYPE:
			{
				disDotLenght = index->disLenght&0x00ff;
				disIntegerLenght = index->disLenght>>8;
				Length =  builtLcdText(dataTemp,DIS_INSIDE_16BIT_TYPE,index->inputIndex,inputData,0);
				Length =  arrangeDispBuffer(dataTemp,disDat,Length, disDotLenght,disIntegerLenght);

				DelAsciiInvalidZeroEx(disDat,Length);
				if((index->inputIndex>=127)&&(index->inputIndex<=142)) 
				{ 
					dataIndex = Power_Current_Valve[index->inputIndex-127];
					dataIndex *=7;
					//dataIndex /=7;//大于70%
					//if(dataIndex>5)dataIndex-=5;

					if(inputData>dataIndex) 
					{
					Power_Current_Valve_St |=  1<<(index->inputIndex-127);
					} 

					if(Power_Current_Valve_St&(1<<(index->inputIndex-127)))
					WriteColor_StringToAddr(index->charIndex,BG_COLOR_CYAN|CH_COLOR_RED,disDat,Length,0);
					else 
					WriteColor_StringToAddr(index->charIndex,BG_COLOR_CYAN|CH_COLOR_GREEN,disDat,Length,0);

				}
				else 
				{
					WriteColor_StringToAddr(index->charIndex,index->color,disDat,Length,0);
				}

				WriteColor_StringToAddr(index->charIndex+Length, index->color,index->szUnit,stringLenght,0);  
				break;
			}
		case DIS_INSIDE_32BIT_TYPE:
		   disDotLenght = index->disLenght&0x00ff;
		   disIntegerLenght = index->disLenght>>8;
		   Length =  builtLcdText(dataTemp,DIS_INSIDE_32BIT_TYPE,index->inputIndex,inputData,0);
		   Length =  arrangeDispBuffer(dataTemp,disDat,Length, disDotLenght,disIntegerLenght);
		   DelAsciiInvalidZeroEx(disDat,Length);
		   WriteColor_StringToAddr(index->charIndex,index->color,disDat,Length,0);
		   WriteColor_StringToAddr(index->charIndex+Length, index->color,index->szUnit,stringLenght,0);  
		   break;
		case DIS_VERSION_TTPE:
		   	switch(index->inputIndex)   
			{
				case DASHBOARD_NODE_ID:     inputData = CompareData(USR_s_OV.DashboardVersion,InsideAscii[0],8); 
				                      if(inputData)WriteColor_StringToAddr(index->charIndex,index->color,USR_s_OV.DashboardVersion,8,0);break;
				case FRONT_DRIVER_NODE_ID:  inputData = CompareData(USR_s_OV.frontDriverVersion,InsideAscii[1],8);  
				                  if(inputData)WriteColor_StringToAddr(index->charIndex,index->color,USR_s_OV.frontDriverVersion,8,0);break;
				case TOP_DRIVER_NODE_ID:    inputData = CompareData(USR_s_OV.topDriverVersion,InsideAscii[2],8);
				                  if(inputData)WriteColor_StringToAddr(index->charIndex,index->color,USR_s_OV.topDriverVersion,8,0);break;
				case BACK_DRIVER_NODE_ID:   inputData = CompareData(USR_s_OV.backDriverVersion,InsideAscii[3],8); 
				                  if(inputData)WriteColor_StringToAddr(index->charIndex,index->color,USR_s_OV.backDriverVersion,8,0);break;
				case MIDDLE_DRIVER_NODE_ID: inputData = CompareData(USR_s_OV.middleDriverVersion,InsideAscii[4],8);
				                  if(inputData)WriteColor_StringToAddr(index->charIndex,index->color,USR_s_OV.middleDriverVersion,8,0);break;
				case POWER_MODULE_NODE_ID:  inputData = CompareData(USR_s_OV.powerVersion,InsideAscii[5],8);
				                  if(inputData)WriteColor_StringToAddr(index->charIndex,index->color,USR_s_OV.powerVersion,8,0);break;
				case POWER_CONTOROL_NODE_ID:inputData = CompareData(USR_s_OV.PowerContorolVersion,InsideAscii[6],8);
				                      if(inputData)WriteColor_StringToAddr(index->charIndex,index->color,USR_s_OV.PowerContorolVersion,8,0);break;
				case CONFIG_VERSION_ID:     inputData = CompareData(USR_s_OV.configVersion,InsideAscii[7],8);
				                      if(inputData)WriteColor_StringToAddr(index->charIndex,index->color,USR_s_OV.configVersion,8,0);break;
				default:break;
			}
		    break;
		case DIS_SYS_DATA_TYPE: 
		     dot = index->disLenght&0x00ff;                       
		     showWord(dataTemp,inputData,dot); 
		     if(dot) dispLenght=1;
		     else  dispLenght = 0;
		     dispLenght = dispLenght + dot;
		     dispLenght +=(index->disLenght>>8);
		     dispStart = 10- dispLenght;
		     charIndex = &dataTemp[dispStart]; 
		     WriteColor_StringToAddr(index->charIndex, index->color,charIndex,dispLenght,0);
		     WriteColor_StringToAddr(index->charIndex+dispLenght, index->color,index->szUnit,stringLenght,0);
		    break;  
		case MULTIPGCKAGE_TYPE: 
			{
				dot = index->disLenght&0x00ff;                       
				showWord(dataTemp,inputData,dot); 
				if(inputData==0xfffffe) 
				{
					for(i=0;i<20;i++)   dataTemp[i] = 0x20;
				}
				if(dot) dispLenght=1;
				else  dispLenght = 0;
				dispLenght = dispLenght + dot;
				dispLenght +=(index->disLenght>>8);
				dispStart = 10- dispLenght;
				charIndex = &dataTemp[dispStart]; 
				WriteColor_StringToAddr(index->charIndex, index->color,charIndex,dispLenght,0);
				WriteColor_StringToAddr(index->charIndex+dispLenght, index->color,index->szUnit,stringLenght,0);
				break;       
			}
		case AUTO_ARRANGE_TYPE:
		    inputData =   index->bitIndex;
		    for(i=0;i<(UINT8)(index->inputIndex&0x00ff);i++) 
		    {
		     showWord(dataTemp,(UINT16)inputData,0);
		     dispLenght =(UINT8)(index->disLenght>>8);
		     if(dispLenght>3)return;
		     charIndex = &dataTemp[10-dispLenght]; //
		     WriteColor_StringToAddr((index->charIndex+i*index->inputLenght), index->color,charIndex,dispLenght,0); 
		     inputData++;
		    }
		    break;
		case DIS_INFO_MANAGE_TYPE:
			{
				//j1939 正常显示
				disDotLenght = index->disLenght&0x00ff;
				disIntegerLenght = index->disLenght>>8;
				Length =  builtLcdText(dataTemp,DIS_J1939_TYPE,index->inputIndex,inputData,0);
				Length =  arrangeDispBuffer(dataTemp,disDat,Length, disDotLenght,disIntegerLenght);
				DelAsciiInvalidZeroEx(disDat,Length);
				WriteColor_StringToAddr(index->charIndex,index->color,disDat,Length,0);
				WriteColor_StringToAddr(index->charIndex+Length, index->color,index->szUnit,stringLenght,0);

				break;
			}
		case DIS_STATUS_WORLD_TYPE:
			{
				typeData = (UINT8)index->inputIndex;
				//DynamicPicNum =  (UINT8)(index->inputIndex>>8);
				startBit = (UINT8)index->bitIndex;
				BitLenght= (UINT8)(index->bitIndex >> 8);  
				switch(typeData) 
				{
					case 1:  
						dataIndex =  index->inputLenght;                                 //j1939 index
						J1939Type  = J1939WordDataConfig[dataIndex].attribute&0x0f; 
						switch(J1939Type) 
						{
						case J1939_Status_Type :  inputData=StorageBuffer[J1939_OFFSET_BYTE+dataIndex]; break;            
						case J1939_Char_Type   :  inputData=StorageBuffer[J1939_OFFSET_BYTE+dataIndex]; break;          
						case J1939_Int_Type    :  inputData=*(UINT16 *)(&StorageBuffer[J1939_OFFSET_BYTE+2*dataIndex-J1939_STATUS_NUMBER-J1939_CHAR_NUMBER]);break;                
						case J1939_Three_Type  :  inputData=*(UINT32 *)(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break; 
						case J1939_Word_Type   :  inputData=*(UINT32 *)(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break;                
						default:inputData = 0 ;break;
						};
						inputData>>=startBit;
						inputData&=((0x000001<<BitLenght)-1);
						break;          //j139;
					case 2:  break;               //内部数据          
					case 0x11: pU8StatusData=  DASHBOARD_MODULE_PHYSICAL_KEYS_ADDRESS;  break;   
					case 0x12: pU8StatusData=  FRONT_MODULE_PHYSICAL_KEYS_ADDRESS;      break;    
					case 0x13: pU8StatusData=  BACK_MODULE_PHYSICAL_KEYS_ADDRESS ;      break;    
					case 0x14: pU8StatusData=  MIDDLE_MODULE_PHYSICAL_KEYS_ADDRESS;     break;    
					case 0x15: pU8StatusData=  TOP_MODULE_PHYSICAL_KEYS_ADDRESS;        break;   
					case 0x16: pU8StatusData=  POWER_MODULE_PHYSICAL_KEYS_ADDRESS;      break;     
					case 0x17: pU8StatusData=  POWER_CONTOROL_MODULE_PHYSICAL_KEYS_ADDRESS; break;         
					case 0x18: pU8StatusData=  DASHBOARD_MODULE_VIRTUAL_KEYS_ADDRESS;       break;   
					case 0x19: pU8StatusData=  FRONT_DRIVER_MODULE_SHORT_OPEN_KEYS_ADDRESS; break;   
					case 0x1A: pU8StatusData=  BACK_DRIVER_MODULE_SHORT_OPEN_KEYS_ADDRESS;   break;  
					case 0x1B: pU8StatusData=  MIDDLE_DRIVER_MODULE_SHORT_OPEN_KEYS_ADDRESS; break;  
					case 0x1C: pU8StatusData=  TOP_DRIVER_MODULE_SHORT_OPEN_KEYS_ADDRESS;    break;  
					case 0x1D: pU8StatusData=  POWER_MODULE_SHORT_OPEN_KEYS_ADDRESS;          break; 
					case 0x1E: pU8StatusData=  POWER_CONTOROL_MODULE_SHORT_OPEN_KEYS_ADDRESS; break;   

					case 0x1F: pU8StatusData=  DASHBOARD_MODULE_PHYSICAL_LOAD_ADDRESS;      break;
					case 0x20: pU8StatusData=  FRONT_MODULE_PHYSICAL_LOAD_ADDRESS ;         break;
					case 0x21: pU8StatusData=  BACK_MODULE_PHYSICAL_LOAD_ADDRESS;           break;
					case 0x22: pU8StatusData=  MIDDLE_MODULE_PHYSICAL_LOAD_ADDRESS;         break;
					case 0x23: pU8StatusData=  TOP_MODULE_PHYSICAL_LOAD_ADDRESS;            break;
					case 0x24: pU8StatusData=  POWER_MODULE_PHYSICAL_LOAD_ADDRESS;          break; 
					case 0x25: pU8StatusData=  POWER_CONTOROL_MODULE_PHYSICAL_LOAD_ADDRESS; break; 
					case 0x50: pU8StatusData=  LOAD_STATE_FROM_PIC_ADDRESS;                 break;   //负载逻辑转图片
					default:break;
				}
				if(typeData>0x10) 
				{
					byteIndex=(UINT8)(index->inputLenght/8);
					bitIndex= (UINT8)(index->inputLenght%8);
					if(bitIndex+BitLenght>8) 
					{ 

					inputData= pU8StatusData[byteIndex+1];
					inputData<<=8;
					inputData|= pU8StatusData[byteIndex];
					} else 
					{
					inputData = pU8StatusData[byteIndex];
					}
					inputData>>=bitIndex;
					inputData&=((0x00001<<BitLenght)-1);   
				}


				if((index->thresholdL>>8)==inputData) 
				{
					dispStart  = (UINT8)(index->thresholdL&0x0f);
					dispLenght = (UINT8)(index->thresholdL&0xf0);
					dispLenght>>=4;
					// for(i=0;i<10;i++)  dataTemp[i] = index->szUnit[i];
					//charIndex = &dataTemp[dispStart]; 
					//for(i=0;i<dispStart;i++) charIndex++;
					WriteColor_StringToAddr(index->charIndex, index->color,&index->szUnit[dispStart],dispLenght,0);
				}
				else if((index->thresholdH>>8)==inputData) 
				{
					dispStart  = (UINT8)(index->thresholdH&0x0f);
					dispLenght = (UINT8)(index->thresholdH&0xf0);
					dispLenght>>=4; 
					//for(i=0;i<10;i++)  dataTemp[i] = index->szUnit[i];
					//charIndex = &dataTemp[dispStart]; 
					//for(i=0;i<dispStart;i++) charIndex++;
					WriteColor_StringToAddr(index->charIndex, index->color,&index->szUnit[dispStart],dispLenght,0);
				} 
				// else 
				//{
				//   WriteColor_StringToAddr(index->charIndex, index->color,"adbf",dispLenght,0);
				//}
				/* else if((index->picNum>>8)==inputData) 
				{
				dispStart  = (UINT8)(index->thresholdL&0x0f);
				dispLenght = (UINT8)(index->thresholdL&0xf0);
				dispLenght>>=4;
				WriteColor_StringToAddr(index->charIndex, index->color,&(index->szUnit[dispStart]),dispLenght,0); 
				}*/

				// else   picIndex = HSAM_PIC_RESERVE;
				// if(picIndex==0x0ffe)   picIndex = HSAM_PIC_RESERVE;
				// if(picIndex==0x0ffd)   picIndex = HSAM_PIC_CLEAR;   //清掉
				/*  if((picIndex!=HSAM_PIC_RESERVE)&&(picIndex!=HSAM_PIC_CLEAR)) 
				{
				if(DynamicPicNum)   //
				{
				if(D_1S_F) 
				{
				DynamicCnt++; 
				D_1S_F=0;
				}
				picIndex +=(DynamicCnt%DynamicPicNum);  
				}

				} */
				break;
			}

		default:break;
	}

}
/*****************************************************************************************
函数名vvoid doInterfaceOsdlogic(UINT8 index,UINT8 curPage) 
功能C根据逻辑 处理数据
参数说明：UINT8 index -> 界面索引
******************************************************************************************/
void doInterfaceOsdlogic(UINT8 index,UINT8 curPage) 
{
    UINT8 	i,j;
   // UINT16 	k;
    UINT32 	inputData;
    UINT16 	logicIndex;
    UINT16 	logicBufferIndex;
    UINT8  	bufferIndex;
    UINT8  	byteLenght;
    UINT8  	logicLenght;
    UINT8  	J1939Type;
    UINT16 	dataIndex;
    UINT32 	inputDataTemp;
    UINT8  	bitIndex;
	UINT8  byteIndex;
    UINT8 	BitLenght;
    UINT8  	get_min_max_val;
    UINT8  	*pStr;
	//UINT8	index1,index2;
	//UINT8	num;
	UINT8 cnt;
	//UINT8	storeHead,storeBias,storeLogicLocation;
	//UINT8 	iFreedom;
	//UINT8	src;//数据来源     存储管理案例用
	//UINT16	srcIndex;//来源索引
    OSD_LOGIC_STRUCT  osdindex;
	//StorageManager1_struct storageManager1Cfg;
	//StorageManager2_struct storageManager2Cfg;
    OSD_WIN_STRUCT * osdConfig;
	
	///////////翻页清除osd/////////////////////////
	//if(curPage!=LcdMsg.osdPage)
 	if(LcdMsg.curPage!= LcdMsg.osdPage)
	{
		LcdMsg.osdPage =  LcdMsg.curPage;//curPage;
		for(i=0;i<4;i++) 
		{  
			osdConfig = (OSD_WIN_STRUCT *)(&(InterfaceInfo[index].osdWin[i]));
			if(osdConfig->attribute&0x8000) 
			{
				switch(osdConfig->initMode) 
				{
					case 1:
						WriteClearStringToAddr(osdConfig->charIndex,BG_COLOR_BLACK|CH_COLOR_BLACK,0x20,osdConfig->w* osdConfig->h, 0);
						break;
					default:
						WriteClearStringToAddr(osdConfig->charIndex,osdConfig->color,0x20,osdConfig->w* osdConfig->h, 0);
						break;
				}                  
			}
			for(j=0;j<OSD_BUFFER_MAX;j++)
				OsdDataTemp[i][j]=0xffffffff;  	
		} 
	} 
/*********************************逻辑处理*********************************/
   	for(i=0;i<4;i++) 
	{ 	
		logicIndex = InterfaceInfo[index].osdWin[i].attribute;
		logicBufferIndex = logicIndex&0x0fff;
		logicLenght = InterfaceInfo[index].osdWin[i].lenght;
		if((logicIndex&0xc000)==0xc000)   //有效+逻辑
		{ 
			bufferIndex = 0; 
			for(j=0;j<logicLenght;j++) 
			{ 
				if(logicBufferIndex>=585) osdindex = OsdLoicgInfo1[logicBufferIndex-585];   
				else	osdindex = OsdLoicgInfo[logicBufferIndex];
				
				logicBufferIndex++;
				inputData = 0;
				if(osdindex.page!=LcdMsg.osdPage) 
				{
					if(osdindex.mode != DIS_SYS_DATA_TYPE )   continue;
				}
				if(bufferIndex >= OSD_BUFFER_MAX)  break;    //防止缓冲器溢出
				switch(osdindex.mode) 
				{
					case 1:
						{
							byteLenght = (UINT8)(osdindex.inputLenght / 8);
							for(cnt=0; cnt<byteLenght; cnt++) 
							{
								inputData<<=8; 
								inputData  += StorageBuffer[osdindex.inputIndex+byteLenght-cnt-1];
							}
							if(OsdDataTemp[i][bufferIndex]!=inputData) 
							{
								OsdDataTemp[i][bufferIndex] = inputData;
								disOsdLogicResult(&osdindex,inputData,0);
							}
							break; 
						}
					case DIS_STRING_OUT_TYPE:
						{
							dataIndex =  osdindex.inputIndex;                                 //j1939 index
							J1939Type  = J1939WordDataConfig[dataIndex].attribute & 0x0f; 
							switch(J1939Type) 
							{
								case J1939_Status_Type :  pStr=(&StorageBuffer[J1939_OFFSET_BYTE+dataIndex]); break;            
								case J1939_Char_Type   :  pStr=(&StorageBuffer[J1939_OFFSET_BYTE+dataIndex]); break;          
								case J1939_Int_Type    :  pStr=(&StorageBuffer[J1939_OFFSET_BYTE+2*dataIndex-J1939_STATUS_NUMBER-J1939_CHAR_NUMBER]);break;                
								case J1939_Three_Type  :  pStr=(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break; 
								case J1939_Word_Type   :  pStr=(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break;                
							}
							if(OsdDataTemp[i][bufferIndex]!=RealTimeCnt[5]) 
							{
								OsdDataTemp[i][bufferIndex]=RealTimeCnt[5];
								byteLenght =(osdindex.disLenght>>8);
								WriteColor_StringToAddr(osdindex.charIndex, osdindex.color,pStr,byteLenght,0);
							}
							break;
						}
					case DIS_J1939_TYPE: 
						{
							dataIndex = osdindex.inputIndex;                                 //j1939 index
							get_min_max_val =  (UINT8)osdindex.thresholdL;
							if(get_min_max_val==2)  //最小值
							{
								inputData = 0xffffffff;
							}         
							do
							{ 
								J1939Type  = J1939WordDataConfig[dataIndex].attribute&0x0f; 
								if(J1939Type!=J1939_Status_Type) 
								{

								BitLenght =  (UINT8)(osdindex.bitIndex>>8);  //长度
								bitIndex  =  (UINT8)(osdindex.bitIndex); 
								// inputDataTemp>>=bitIndex;
								//inputDataTemp&=(((UINT32)1<<BitLenght)-1);  
								}
								switch(J1939Type) 
								{
									case J1939_Status_Type :  inputDataTemp=StorageBuffer[J1939_OFFSET_BYTE+dataIndex]; break;            
									case J1939_Char_Type   :  if((BitLenght>8)&&(BitLenght<17)){
									inputDataTemp=*(UINT16 *)(&StorageBuffer[J1939_OFFSET_BYTE+dataIndex]); 
									} 
									else if(BitLenght>0x20)
									{
									BitLenght-=0x20;
									inputDataTemp=StorageBuffer[J1939_OFFSET_BYTE+dataIndex+1]; 
									inputDataTemp<<=8;
									inputDataTemp|=StorageBuffer[J1939_OFFSET_BYTE+dataIndex];   
									}
									else  inputDataTemp=StorageBuffer[J1939_OFFSET_BYTE+dataIndex];
									break;          
									case J1939_Int_Type    :  inputDataTemp=*(UINT16 *)(&StorageBuffer[J1939_OFFSET_BYTE+2*dataIndex-J1939_STATUS_NUMBER-J1939_CHAR_NUMBER]);break;                
									case J1939_Three_Type  :  inputDataTemp=*(UINT32 *)(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break; 
									case J1939_Word_Type   :  inputDataTemp=*(UINT32 *)(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break;                
								};
								if(J1939Type!=J1939_Status_Type) 
								{

								// BitLenght =  (UINT8)(osdindex.bitIndex>>8);  //长度
								// bitIndex  =  (UINT8)(osdindex.bitIndex); 
								inputDataTemp>>=bitIndex;
								inputDataTemp&=(((UINT32)1<<BitLenght)-1);  
								}

								if(get_min_max_val==0) 
								{
								inputData = inputDataTemp;
								} 
								else if(get_min_max_val==1)   //最大值
								{
								if(inputDataTemp>inputData)    inputData =  inputDataTemp;
								}
								else if(get_min_max_val==2)  //最小值
								{
								if(inputDataTemp<inputData)   inputData =  inputDataTemp;
								} 
								else if(get_min_max_val==3)  //特殊分辨率
								{
								inputData =  inputDataTemp;
								break;
								}
								else if(get_min_max_val==4)  //数字+状态显示
								{
								inputData =  inputDataTemp;
								break;
								}

								else if(get_min_max_val==5)  //数字+选择显示
	                              {
	                                  inputData =  inputDataTemp;
	                                  break;
	                              }
								dataIndex++;

							}while(dataIndex<=osdindex.inputLenght); 

							if(get_min_max_val==3)          //特殊分辨率
							{
								dataIndex =  osdindex.inputLenght;   
								J1939Type  = J1939WordDataConfig[dataIndex].attribute&0x0f;
								switch(J1939Type) 
								{
									case J1939_Status_Type :  inputDataTemp=StorageBuffer[J1939_OFFSET_BYTE+dataIndex]; break;            
									case J1939_Char_Type   :  inputDataTemp=StorageBuffer[J1939_OFFSET_BYTE+dataIndex]; break;          
									case J1939_Int_Type    :  inputDataTemp=*(UINT16 *)(&StorageBuffer[J1939_OFFSET_BYTE+2*dataIndex-J1939_STATUS_NUMBER-J1939_CHAR_NUMBER]);break;                
									case J1939_Three_Type  :  inputDataTemp=*(UINT32 *)(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break; 
									case J1939_Word_Type   :  inputDataTemp=*(UINT32 *)(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break;                
								};
								if(inputDataTemp==0xff) inputData*=3; 
								else inputData*=2;
								//else if(inputDataTemp==0x03)else   inputDataTemp = 2;
								//InsideData[6] = inputDataTemp; 
							} 
							else if(get_min_max_val==4) 
							{
								dataIndex =  osdindex.inputLenght;   
								J1939Type  = J1939WordDataConfig[dataIndex].attribute&0x0f;
								switch(J1939Type) 
								{
									case J1939_Status_Type :  inputDataTemp=StorageBuffer[J1939_OFFSET_BYTE+dataIndex]; break;            
									case J1939_Char_Type   :  inputDataTemp=StorageBuffer[J1939_OFFSET_BYTE+dataIndex]; break;          
									case J1939_Int_Type    :  inputDataTemp=*(UINT16 *)(&StorageBuffer[J1939_OFFSET_BYTE+2*dataIndex-J1939_STATUS_NUMBER-J1939_CHAR_NUMBER]);break;                
									case J1939_Three_Type  :  inputDataTemp=*(UINT32 *)(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break; 
									case J1939_Word_Type   :  inputDataTemp=*(UINT32 *)(&StorageBuffer[J1939_OFFSET_BYTE + 4*dataIndex-3*J1939_STATUS_NUMBER - 3*J1939_CHAR_NUMBER-2*J1939_INT_NUMBER]);break;                
								};
							}
							else if(get_min_max_val==5) 
                            {
                               pU8StatusData=  DASHBOARD_MODULE_VIRTUAL_KEYS_ADDRESS;
                               byteIndex=(UINT8)(osdindex.inputLenght/8);    
                               bitIndex= (UINT8)(osdindex.inputLenght%8);
                               inputDataTemp = pU8StatusData[byteIndex]>> bitIndex;
                               inputDataTemp &=0x01;
                            }
							else 
							{
							inputDataTemp = 0;
							}


							if(get_min_max_val==4) 
                                {
                                  OsdDataTemp[i][bufferIndex] = inputData;
                                  disOsdLogicResult(&osdindex,inputData,inputDataTemp);
                                
                                } 
                                else if(get_min_max_val==5) 
                                {
                                       if(inputDataTemp)
                                       disOsdLogicResult(&osdindex,inputData,0);     
                                }
                                else
                                {
                                  if(OsdDataTemp[i][bufferIndex]!=inputData) 
                                  {
                                     OsdDataTemp[i][bufferIndex] = inputData;
                                     disOsdLogicResult(&osdindex,inputData,0);
                                  } 
                                }
							break; 
						}
					case DIS_INSIDE_16BIT_TYPE:
						dataIndex =  osdindex.inputIndex;                                 //j1939 index  
						inputData =  InsideData[dataIndex];
						if(OsdDataTemp[i][bufferIndex]!=inputData) 
						{
						OsdDataTemp[i][bufferIndex] = inputData;
						disOsdLogicResult(&osdindex,inputData,0);
						} 
						break; 
					case  DIS_INSIDE_32BIT_TYPE: 
						dataIndex =  osdindex.inputIndex;                                 // index 
						switch(dataIndex) 
						{
						case 1: inputData = USR_s_DeviceConfigData.TotalDistance/10;  break;
						case 2: inputData = USR_s_DeviceConfigData.RelativeDistance/10; break;
						case 3: inputData = USR_s_OV.HundredKilometerFuelConsume;  break;
						}
						if(OsdDataTemp[i][bufferIndex]!=inputData) 
						{
						OsdDataTemp[i][bufferIndex] = inputData;
						disOsdLogicResult(&osdindex,inputData,0);
						} 
						break;
					case DIS_VERSION_TTPE:
						disOsdLogicResult(&osdindex,0,0);
						break;
					case DIS_COLUMN_WARM://亮柱子报警 
						{
							if(osdindex.inputIndex==1)
							{
								inputData=LCD_LEFT_WARM_LOAD;   //add
								if(OsdDataTemp[i][bufferIndex]!=inputData) 
								{
								OsdDataTemp[i][bufferIndex] = inputData;
								DisColumnWarn(&osdindex,(UINT8)inputData);
								} 
							} 
							else if(osdindex.inputIndex==2) 
							{
							inputData=LCD_RIGHT_WARM_LOAD;  //add
							if(OsdDataTemp[i][bufferIndex]!=inputData) 
							{
							OsdDataTemp[i][bufferIndex] = inputData;
							DisColumnWarn(&osdindex,(UINT8)inputData);
							} 
							}

							break; 
						}
					case DIS_SYS_TIME_TYPE:
						{
							dataIndex =  osdindex.inputIndex; 
	                        if(dataIndex==0x7f) //当前充电时间
	                        {							
								if(OsdDataTemp[i][bufferIndex]!=recordingStTime[5]) 
								{ 
									OsdDataTemp[i][bufferIndex] = recordingStTime[5];
									dispSysTime(&osdindex,&recordingStTime[3]); 
								}    
	                        } 
	                        else if((dataIndex>=0x80)&&(dataIndex<=0x89)) 
							{
								
							} 
							else
							{
								if(OsdDataTemp[i][bufferIndex]!=RealTimeCnt[5]) 
								{
									OsdDataTemp[i][bufferIndex] = RealTimeCnt[5];
									dispSysTime(&osdindex,&RealTimeCnt[3]); 
								}
								
							}
							break;
						}
					case DIS_STATUS_WORLD_TYPE: 
						{
							if(OsdDataTemp[i][bufferIndex]!=RealTimeCnt[5]) 
							{
								OsdDataTemp[i][bufferIndex] = RealTimeCnt[5];
								disOsdLogicResult(&osdindex,inputData,0);
							}
						}
					case DIS_SYS_DAY_TYPE:
						{
							dataIndex =  osdindex.inputIndex; 
							if(dataIndex==0x7f) 
							{
								if(OsdDataTemp[i][bufferIndex]!=recordingStTime[2]) 
								{ 
									OsdDataTemp[i][bufferIndex] = recordingStTime[2];
									 dispSysDay(&osdindex,&recordingStTime[0]); 
								}       
							} 
							else if((dataIndex >= 0x80)&&(dataIndex<=0x89)) 
							{
								
							} 
							else 
							{
								if(OsdDataTemp[i][bufferIndex]!=RealTimeCnt[2]) 
								{ 
									OsdDataTemp[i][bufferIndex] = RealTimeCnt[2];
									 dispSysDay(&osdindex,&RealTimeCnt[0]);
								}
							}
							break; 
						}
					case 5:
						disSysDistance(&osdindex);
						break;
					case DIS_SYS_DATA_TYPE:
						{
							dataIndex =  osdindex.inputIndex;                                 //j1939 index  
							switch(dataIndex) 
							{  //1->页  2->光标  3->故障第几页    4->故障总个数   5->故障共几页  6->
								case 1 :  inputData =(UINT32 )LcdMsg.pageCnt;//LcdMsg.curPage;   //SecCnt;//
								break;   //页           
								case 2 :  inputData=(UINT32)LcdMsg.cursor;   break;   //光标  
								case 3 :  inputData=(UINT32)LcdMsg.cursor/5;          //故障第几页 
								if(LcdMsg.cursor%5) inputData++;   
								inputData++;  break;        
								case 4 :  inputData=(UINT32)dis_count;       break;   //故障总个数
								case 5:   inputData=(UINT32)dis_count/5;              //故障共几页
								if(dis_count%5) inputData++;break;

								case 6:   inputData=(UINT32) MultiPgckage_AvailableByte_Num[0];break;   //故障总个数
								case 7:   inputData=(UINT32)MultiPgckage_AvailableByte_Num[0]/5;                //故障共几页
								if(MultiPgckage_AvailableByte_Num[0]%5) inputData++;break;

								case 8:   inputData=(UINT32) MultiPgckage_AvailableByte_Num[1];break;   //故障总个数
								case 9:   inputData=(UINT32)MultiPgckage_AvailableByte_Num[1]/5;                //故障共几页
								if(MultiPgckage_AvailableByte_Num[1]%5) inputData++;break;

								case 10:   inputData=(UINT32) MultiPgckage_AvailableByte_Num[2];break;   //故障总个数
								case 11:   inputData=(UINT32)MultiPgckage_AvailableByte_Num[2]/5;                //故障共几页
								if(MultiPgckage_AvailableByte_Num[2]%5) inputData++;break;

								default:break;              
								};
							if(OsdDataTemp[i][bufferIndex]!=inputData) 
							{
							OsdDataTemp[i][bufferIndex] = inputData;
							disOsdLogicResult(&osdindex,inputData,0);
						}  
							break;
						}
					case  AUTO_ARRANGE_TYPE:
						if(OsdDataTemp[i][bufferIndex]!=LcdMsg.curPage) 
						{
						OsdDataTemp[i][bufferIndex] = LcdMsg.curPage;
						disOsdLogicResult(&osdindex,inputData,0);
						}  
						break;
					case MULTIPGCKAGE_TYPE:
						{
							dataIndex =  LcdMsg.cursor;
							dataIndex +=  osdindex.inputLenght;
							bitIndex =  (UINT8)(osdindex.inputIndex>>8); //多包
							BitLenght=  (UINT8)(osdindex.inputIndex&0xff);//type 
							if(bitIndex==1) 
							{
							inputData = EngineDiagnosePackageData[dataIndex];
							if(BitLenght==0) 
							{
							inputData  =  dataIndex+1;
							} 
							else if(BitLenght==1)     {inputData>>=16;  inputData&=0x1f; }//fmi
							else if(BitLenght==2)
							{
							inputDataTemp = inputData&0x0000ffff; 
							inputData= ((inputData>>5)&0x070000);
							inputData |=inputDataTemp; 
							}

							if(dataIndex>=MultiPgckage_AvailableByte_Num[0]) inputData=0xfffffe;

							}
							else if(bitIndex==2) 
							{
							inputData = EngineDiagnosePackageData1[dataIndex]; 
							if(BitLenght==0) 
							{
							inputData  =  dataIndex+1;
							} 
							else if(BitLenght==1)     
							{
							inputData>>=16;  inputData&=0x1f;
							}//fmi
							else if(BitLenght==2)
							{
							inputDataTemp = inputData&0x0000ffff; 
							inputData= ((inputData>>5)&0x070000);
							inputData |=inputDataTemp; 
							}
							if(dataIndex>=MultiPgckage_AvailableByte_Num[1]) inputData=0xfffffe;
							}

							else if(bitIndex==3) 
							{
							inputData = EngineDiagnosePackageData2[dataIndex]; 
							if(BitLenght==0) 
							{
							inputData  =  dataIndex+1;
							} 
							else if(BitLenght==1)     
							{
							inputData>>=16;  inputData&=0x1f;
							}//fmi
							else if(BitLenght==2)
							{
							inputDataTemp = inputData&0x0000ffff; 
							inputData= ((inputData>>5)&0x070000);
							inputData |=inputDataTemp; 
							}
							if(dataIndex>=MultiPgckage_AvailableByte_Num[2]) inputData=0xfffffe;
							}



							if(OsdDataTemp[i][bufferIndex]!=inputData) 
							{
								OsdDataTemp[i][bufferIndex] = inputData;
								disOsdLogicResult(&osdindex,inputData,0);     
							}  
							break;
						}
					case DIS_INFO_MANAGE_TYPE://
						/*{
							//inputIndex		 b7-0  哪种数据
							//inputLenght		b11-8字节长度，b7-0第n个元素
							//BitIndex		b15-8 一级索引，b7-0二级索引
							dataIndex =  (UINT8)osdindex.inputIndex; 			
							//byteLenght = (UINT8)osdindex.inputLenght >> 8;//字节数
							num = (UINT8)osdindex.inputLenght;//保存的第n组数据(从0开始)

							index1 = (UINT8)(osdindex.bitIndex >> 8);//一级索引
							index2 = (UINT8)osdindex.bitIndex;
							storageManager1Cfg = StorageManagerCONST[index1];
							storeLogicLocation = storageManager1Cfg.logicLocation + index2;
							storageManager2Cfg = InformationCONST[storeLogicLocation];
							//字节长
							byteLenght = storageManager2Cfg.attribute & 0x0f;
							if(byteLenght == 0)	byteLenght = 1;//字节长度改从逻辑表中获取
							
							//存储数据的地址
							storeHead =THE_BASE_ADDRESS + storageManager2Cfg.dstIndex;//基地址
							if(num >= haveNum[index1])	break;//条数超出
							if(saveCnt[index1] > num)
								num = saveCnt[index1] - num - 1;
							else	
								num = storageManager1Cfg.num - 1 + saveCnt[index1] - num;	
							storeBias = byteLenght * num;
							Eeprom_Read_Fact_Ex(storeHead + storeBias , read_data, byteLenght);
							inputData = read_data[0];
							for(iFreedom = 1; iFreedom < byteLenght; iFreedom++)
							{
								inputData = inputData << 8;
								inputData |= read_data[iFreedom];
							}
							
							if(OsdDataTemp[i][bufferIndex] != inputData)
							{
								OsdDataTemp[i][bufferIndex] = inputData;

								//数据来源
								src = (UINT8)(storageManager2Cfg.srcIndex >> 12);
								srcIndex = storageManager2Cfg.srcIndex & 0x0fff;

								switch(src)
								{
									case srcFROMJ1939:
										{
											osdindex.mode = DIS_J1939_TYPE;
											osdindex.inputIndex = srcIndex;

											disOsdLogicResult(&osdindex,inputData,0);//注意osdindex.ThresholdL  
											break;
										}
									case srcFROMINSIDE:
										{
											//
											break;
										}
									case 2://时间
										{
											dispSysTime(&osdindex,read_data);
											break;
										}
									case 3://日期
										{
											dispSysDay(&osdindex,read_data);
											break;
										}
									default:	break;
								}
							}
						}*/
					default:break;

				}
				bufferIndex++;
			}
		}
	}
}

/***************************************************************************************************************************
诊断
brief : 
parameter:					devModule
							pageCnt
							itemNumber:	该模式的总诊断条数
							mode
**************************************************************************************************************************/
void doDiagnose(UINT8 devModule,UINT8 pageCnt,UINT8 itemNumber,UINT8 mode) //0正常显示 1 清除
{ 
  	DIAGNOSE_STRUCT  CopyModuleDiagnose = ModuleDiagnose;
	switch(devModule) 
	{
		case DASHBOARD_NODE_ID:   		Diagnose_State(devModule,CopyModuleDiagnose.DashboardDiagnoseInfo,DashboardDiagnose, pageCnt,itemNumber,mode);break;
		case FRONT_DRIVER_NODE_ID:		Diagnose_State(devModule,CopyModuleDiagnose.FrontDriverDiagnoseInfo,FrontDriverDiagnose, pageCnt,itemNumber,mode);break;
		case TOP_DRIVER_NODE_ID:   		Diagnose_State(devModule,CopyModuleDiagnose.TopDriverDiagnoseInfo,TopDriverDiagnose, pageCnt,itemNumber,mode);break;
		case BACK_DRIVER_NODE_ID:  		Diagnose_State(devModule,CopyModuleDiagnose.BackDriverDiagnoseInfo,BackDriverDiagnose, pageCnt,itemNumber,mode);break;
		case MIDDLE_DRIVER_NODE_ID:		Diagnose_State(devModule,CopyModuleDiagnose.MiddleDriverDiagnoseInfo,MiddleDriverDiagnose, pageCnt,itemNumber,mode);break;
		case POWER_MODULE_NODE_ID:  	Diagnose_State(devModule,CopyModuleDiagnose.PowerDiagnoseInfo,PowerDiagnose, pageCnt,itemNumber,mode);break;
		case POWER_CONTOROL_NODE_ID:	Diagnose_State(devModule,CopyModuleDiagnose.PowerContorolDiagnoseInfo,PowerContorolDiagnose, pageCnt,itemNumber,mode);break;
		default:break;
	}
}
UINT8 oldDiagnoseContent[18] = {0};

void	Diagnose_State(UINT8 devModule,UINT8 * pDiagnoseType,DIAGNOSE_STATUS_STRUCT *DiagnoseContent,UINT8 pageCnt,UINT8 itemNumber,UINT8 mode)
{

	UINT8 displayCnt,displayNum,cnt;
	UINT8 row;
	UINT8 line;
	UINT8 diagnoseType;
	UINT8 diagnoseSt;
	UINT8 dataTemp;
	UINT8 Disp_Diagnose_Flag;
	UINT8 backColor;
	UINT8 module_error;
	
	
	UINT8 i = 0;
	UINT8 refish = 0;
	if(devModule == DASHBOARD_NODE_ID) i = 18;
	else if(devModule == POWER_CONTOROL_NODE_ID) i = 6;
	else i = 13;

	for(int j = 0;j < i; j++){
		if(oldDiagnoseContent[j] != DiagnoseContent[j].diag){
			oldDiagnoseContent[j] = DiagnoseContent[j].diag;
			refish = 1;
		}
	}
	if(!refish) return;
	
	
	backColor = 0X30;//InterfaceInfo[4].osdWin[0].color&0xf0;  启用无背景颜色
	displayCnt = (pageCnt-1)*DIAGNOSE_PAGE_LINE; //显示开始位置
	if(displayCnt >= itemNumber)		return;
	
	displayNum = itemNumber - displayCnt;  //显示长度
	if(displayNum>DIAGNOSE_PAGE_LINE) displayNum = DIAGNOSE_PAGE_LINE;
	for(cnt=0;cnt<displayNum;cnt++) 
	{
		row  = (UINT8)((displayCnt+cnt)/2);
		line = (UINT8)((displayCnt+cnt)%2);
		line = 1- line;    //调整位置 第一个为高4bit 第二个为低4bit
		dataTemp = line * 4;
		diagnoseType = pDiagnoseType[row]>>dataTemp;
		diagnoseType&=0x0f;  //得到显示类型
		row  = (UINT8)((displayCnt+cnt)/4);
		line = (UINT8)((displayCnt+cnt)%4);
		dataTemp = line*2;
		diagnoseSt = DiagnoseContent[row].diag>>dataTemp;
		diagnoseSt&=0x03;   //得到状态
		if(mode==1) 
		{
			WriteColor_StringToAddr(cnt,backColor|CH_COLOR_RED,(UINT8*)" ",1,0);
		}  
		else
		{
			if(diagnoseType==DIAGNOSE_LOAD)  //1->负载状态  显示
			{
				switch(diagnoseSt)
				{
					case LOAD_RUNING: 
					Disp_Diagnose_Flag=FONT_LOAD_ON;
					WriteColor_StringToAddr(cnt,backColor|CH_COLOR_GREEN,&Disp_Diagnose_Flag,1,0);
					break;
					case LOAD_SHORT: 
					Disp_Diagnose_Flag=FONT_LOAD_SHORT;
					WriteColor_StringToAddr(cnt,backColor|CH_COLOR_RED,&Disp_Diagnose_Flag,1,0);
					break;
					case LOAD_CLOSE: 
					Disp_Diagnose_Flag=FONT_LOAD_OFF;
					WriteColor_StringToAddr(cnt,backColor|CH_COLOR_WHITE,&Disp_Diagnose_Flag,1,0);
					break;
					case LOAD_OPEN: 
					Disp_Diagnose_Flag=FONT_LOAD_OPEN;
					WriteColor_StringToAddr(cnt,backColor|CH_COLOR_RED,&Disp_Diagnose_Flag,1,0);
					break;
					default:
					Disp_Diagnose_Flag=FONT_CLEAR;
					WriteColor_StringToAddr(cnt,backColor|CH_COLOR_RED,&Disp_Diagnose_Flag,1,0);
					break;
				}
			}
			else if(diagnoseType==DIAGNOSE_SWITCH)//2->开关状态  显示
			{
				switch(diagnoseSt)
				{
				case KeyOn: 
				Disp_Diagnose_Flag=FONT_KEY_ON;
				WriteColor_StringToAddr(cnt,backColor|CH_COLOR_GREEN,&Disp_Diagnose_Flag,1,0);
				break;
				case KeyOff: 
				Disp_Diagnose_Flag=FONT_KEY_OFF;
				WriteColor_StringToAddr(cnt,backColor|CH_COLOR_WHITE,&Disp_Diagnose_Flag,1,0);
				break;
				default:
				Disp_Diagnose_Flag=FONT_CLEAR;
				WriteColor_StringToAddr(cnt,backColor|CH_COLOR_RED,&Disp_Diagnose_Flag,1,0);
				break;
				}
			} 
			if(diagnoseType==DIAGNOSE_SENSOR) //3->传感器状态  显示
			{
			module_error = 0; 
			switch(devModule) 
			{
			case DASHBOARD_NODE_ID:     module_error = 0; 	break;
			case FRONT_DRIVER_NODE_ID:  if(FRONT_DRIVE_MODULE_ERROR_F)module_error=1;break;
			case TOP_DRIVER_NODE_ID:   	if(TOP_DRIVE_MODULE_ERROR_F)module_error=1;break;
			case BACK_DRIVER_NODE_ID:  	if(BACK_DRIVE_MODULE_ERROR_F)module_error=1;break;
			case MIDDLE_DRIVER_NODE_ID:	if(MIDDLE_DRIVE_MODULE_ERROR_F)module_error=1;break;
			case POWER_MODULE_NODE_ID:  if(POWER_MODULE_ERROR_F)module_error=1;break;
			default:break;
			}
			if(module_error==0) 
			{
			switch(diagnoseSt)   //
			{
			case SENSOR_ERROR:
			Disp_Diagnose_Flag = FONT_LOAD_SHORT;
			WriteColor_StringToAddr(cnt,backColor|CH_COLOR_RED,&Disp_Diagnose_Flag,1,0);    //传感器故障
			break;
			default:
			Disp_Diagnose_Flag = FONT_LOAD_ON;
			WriteColor_StringToAddr(cnt,backColor|CH_COLOR_GREEN,&Disp_Diagnose_Flag,1,0);  //传感器开
			break;
			}
			} else 
			{
			Disp_Diagnose_Flag = FONT_LOAD_SHORT; 
			WriteColor_StringToAddr(cnt,backColor|CH_COLOR_RED,&Disp_Diagnose_Flag,1,0);    //传感器故障
			}
			}
			else if(diagnoseType==DIAGNOSE_BEI_YONG)   //
			{
			Disp_Diagnose_Flag=FONT_LOAD_OFF;
			WriteColor_StringToAddr(cnt,backColor|CH_COLOR_WHITE,&Disp_Diagnose_Flag,1,0);
			}
			else if(diagnoseType==DIAGNOSE_ENABLE_UNABLE) 
			{
			WriteColor_StringToAddr(cnt,backColor|CH_COLOR_WHITE,(UINT8*)" ",1,0);
			} 
			else if(diagnoseType==DIAGNOSE_CONSTANT) 
			{
			Disp_Diagnose_Flag = FONT_LOAD_ON;
			WriteColor_StringToAddr(cnt,backColor|CH_COLOR_GREEN,&Disp_Diagnose_Flag,1,0);  //传感器开
			} 
			else if(diagnoseType==DIAGNOSE_CATCH) 
			{
			switch(diagnoseSt)
			{

			case 1: 
			Disp_Diagnose_Flag=FONT_LOAD_ON;
			WriteColor_StringToAddr(cnt,backColor|CH_COLOR_GREEN,&Disp_Diagnose_Flag,1,0);
			break;
			case 0: 
			Disp_Diagnose_Flag=FONT_LOAD_OFF;
			WriteColor_StringToAddr(cnt,backColor|CH_COLOR_WHITE,&Disp_Diagnose_Flag,1,0);
			break;
			default:
			break; 
			}
			}


		}
	}
	
	if(devModule==DASHBOARD_NODE_ID&&pageCnt==3) 
	{
		for(;cnt<17;cnt++) 	WriteColor_StringToAddr(cnt,backColor|CH_COLOR_RED,(UINT8*)" ",1,0);
		Disp_Diagnose_Flag = FONT_KEY_OFF;
		WriteColor_StringToAddr(17,backColor|CH_COLOR_WHITE,&Disp_Diagnose_Flag,1,0);  //开关断开
		Disp_Diagnose_Flag = FONT_KEY_ON;
		WriteColor_StringToAddr(18,backColor|CH_COLOR_GREEN,&Disp_Diagnose_Flag,1,0);  //开关接通
		Disp_Diagnose_Flag = FONT_LOAD_OFF;
		WriteColor_StringToAddr(19,backColor|CH_COLOR_WHITE,&Disp_Diagnose_Flag,1,0);  //负载灭
		Disp_Diagnose_Flag = FONT_LOAD_ON;
		WriteColor_StringToAddr(20,backColor|CH_COLOR_GREEN,&Disp_Diagnose_Flag,1,0);  //负载亮
		Disp_Diagnose_Flag = FONT_LOAD_SHORT;
		WriteColor_StringToAddr(21,backColor|CH_COLOR_RED,&Disp_Diagnose_Flag,1,0);    //负载短路
		Disp_Diagnose_Flag = FONT_LOAD_OPEN;
		WriteColor_StringToAddr(22,backColor|CH_COLOR_RED,&Disp_Diagnose_Flag,1,0);    //负载开路
		Disp_Diagnose_Flag = FONT_LOAD_SHORT;
		WriteColor_StringToAddr(23,backColor|CH_COLOR_WHITE,&Disp_Diagnose_Flag,1,0);  //传感器关
		Disp_Diagnose_Flag = FONT_LOAD_ON;
		WriteColor_StringToAddr(24,backColor|CH_COLOR_GREEN,&Disp_Diagnose_Flag,1,0);  //传感器开
		Disp_Diagnose_Flag = FONT_LOAD_SHORT;
		WriteColor_StringToAddr(25,backColor|CH_COLOR_RED,&Disp_Diagnose_Flag,1,0);    //传感器故障

		} 
	else 
	{
		for(;cnt<DIAGNOSE_PAGE_LINE;cnt++) 	WriteColor_StringToAddr(cnt,backColor|CH_COLOR_RED,(UINT8*)" ",1,0);
	}
	/*	
	else if(Diagnose_Type==DIAGNOSE_SENSOR)
	{
	unsigned char ModuleError=0;

	switch(Diagnose_Content)
	{
	case SensorErorrData: 					
	Disp_Diagnose_Flag=FONT_WORD_DUAN_LU;
	WriteColor_StringToAddr(Diagnose_Content_Position,BG_COLOR_RED|CH_COLOR_BLACK,&Disp_Diagnose_Flag,1,0);	
	break;
	default:
	if(Diagnose_Module==DIAGNOSE_FRONT_DRIVE)
	ModuleError=FrontDriveErrorFlag;
	else if(Diagnose_Module==DIAGNOSE_BACK_DRIVE)
	ModuleError=BackDriveErrorFlag;
	else if(Diagnose_Module==DIAGNOSE_TOP_DRIVE)
	ModuleError=TopDriveErrorFlag;
	if(ModuleError)
	{
	Disp_Diagnose_Flag=FONT_WORD_DUAN_LU;
	WriteColor_StringToAddr(Diagnose_Content_Position,BG_COLOR_WHITE|CH_COLOR_BLACK,&Disp_Diagnose_Flag,1,0);
	}
	else
	{
	Disp_Diagnose_Flag=FONT_WORD_LIANG;
	WriteColor_StringToAddr(Diagnose_Content_Position,BG_COLOR_GREEN|CH_COLOR_BLACK,&Disp_Diagnose_Flag,1,0);
	}
	break;
	}
	}
	else if(Diagnose_Type==DIAGNOSE_CATCH)
	{
	switch(Diagnose_Content)
	{
	case CATCH_SENSOR_SIGNAL_NO:
	Disp_Diagnose_Flag=FONT_WORD_BU_LIANG;
	WriteColor_StringToAddr(Diagnose_Content_Position,BG_COLOR_WHITE|CH_COLOR_BLACK,&Disp_Diagnose_Flag,1,0);
	break;
	default:
	Disp_Diagnose_Flag=FONT_WORD_LIANG;
	WriteColor_StringToAddr(Diagnose_Content_Position,BG_COLOR_GREEN|CH_COLOR_BLACK,&Disp_Diagnose_Flag,1,0);
	break;
	}
	}
	else if(Diagnose_Type==DIAGNOSE_ENABLE_UNABLE)
	{
	switch(Diagnose_Content)
	{
	case STATE_UNABLE:
	Disp_Diagnose_Flag=FONT_WORD_BU_LIANG;
	WriteColor_StringToAddr(Diagnose_Content_Position,BG_COLOR_WHITE|CH_COLOR_BLACK,&Disp_Diagnose_Flag,1,0);
	break;
	case STATE_ENABLE:
	Disp_Diagnose_Flag=FONT_WORD_LIANG;
	WriteColor_StringToAddr(Diagnose_Content_Position,BG_COLOR_GREEN|CH_COLOR_BLACK,&Disp_Diagnose_Flag,1,0);
	break;
	default:
	Disp_Diagnose_Flag=FONT_WORD_QING;
	WriteColor_StringToAddr(Diagnose_Content_Position,BG_COLOR_BLACK|CH_COLOR_BLACK,&Disp_Diagnose_Flag,1,0);
	break;
	}
	}
	else
	{
	Disp_Diagnose_Flag=FONT_WORD_QING;
	WriteColor_StringToAddr(Diagnose_Content_Position,BG_COLOR_BLACK|CH_COLOR_BLACK,&Disp_Diagnose_Flag,1,0);
	} */
}
/******************************************************************************************************
函数名：void builtLcdText(UINT8  *pDisBuf,UINT8 attribute)
功能：建立LCD信息显示界面显示内容
参数说明：UINT8  *pDisBuf -> GB2312码
          UINT8 attribute -> 属性
******************************************************************************************************/

/******************************************************************************************************
函数名： void builtLcdText(UINT8  *pDisBuf,UINT8 attribute)
brief			建立LCD信息显示界面显示内容
参数说明：UINT8  *pDisBuf -> GB2312码
          			UINT8 attribute -> 属性
* @brief				把inputDat数据转为字符串输出到pDisBuf中
* @parameter			*pDisBuf:	输出字符串
*						type:	数据来源(类型)
*						index:	索引
*						inputDat:	输入
*						bitval:
* @return
******************************************************************************************************/
UINT8 builtLcdText(UINT8 *pDisBuf,UINT8 type,UINT16 index,UINT32 inputDat,UINT8 bitval)
{
   // UINT16 data;
    UINT32 dataTemp;
    UINT8 dot;
    UINT8 sign;
   // UINT16 scale[5] = {1,10,100,1000,10000};
    UINT32 bitValue;
    UINT8 len;
    UINT8 J1939Type;
    //UINT16 inputIndex;
    UINT8   noSign;
    UINT16  dataType;
    dataTemp = inputDat;
    switch(type)
    {
        case DIS_INSIDE_16BIT_TYPE:   //内部_16
        {                                   
           
            dot = SENSOR_DATA_CONFIG[index].bitValue >> SENSOR_DOT_GRESSION;      //2 2   //113
            if(inputDat!=0xfffe)                //10
            { 
              bitValue = SENSOR_DATA_CONFIG[index].bitValue & SENSOR_BIT_VALUE_MASK;
              dataTemp = inputDat* (UINT32)bitValue;//(UINT32)InsideData[index] 
              sign = sign32Bit(&dataTemp,((UINT32)SENSOR_DATA_CONFIG[index].offset));//* (UINT32)scale[dot]));
            } 
            else 
            {
             sign = 0;
             dataTemp = 0;
            }
                
            if(!dot && !SENSOR_DATA_CONFIG[index].offset)     //无符号整数
            {
                  bit32HexToAscii(pDisBuf,dataTemp);  
                  len=10;
            }
            else if(!dot && SENSOR_DATA_CONFIG[index].offset) //有符号整数
            {                
                bit32HexToAscii(&pDisBuf[1],dataTemp);
                len=11;                
                pDisBuf[0] = ' ';
                if(sign)                                         
                {
                    pDisBuf[0] = '-';
                }        
            }
            else if(dot && SENSOR_DATA_CONFIG[index].offset)  //有符号小数
            {   
                  
                bit32HexToAscii(&pDisBuf[1],dataTemp);
                len=11;          
                pDisBuf[0] = ' ';
                if(sign)                                         
                {
                    pDisBuf[0] = '-';
                }     
                insertDot(pDisBuf,dot,len); 
                len=len+1;
            } 
            else                                                //无符号小数
            {
                 bit32HexToAscii(pDisBuf,dataTemp);
                 len=10; 
                 insertDot(pDisBuf,dot,len); 
                 len=len+1;
            }  
        break;     
        }
        case DIS_J1939_TYPE:          //J1939_8
        {     
            J1939Type  = J1939WordDataConfig[index].attribute&0x0f; 
            dataType   = J1939WordDataConfig[index].attribute&0x0f00;
            bitValue   = J1939WordDataConfig[index].bitValue & 0xffffff; 
            dot        = J1939WordDataConfig[index].bitValue >> 28;
            if(bitval!=0)
            bitValue  =   bitval;
           
            
            dataTemp = dataTemp* bitValue; 
            
            switch(dataType)
            {
              case J1939_OFFSET_DATA_TYPE:
               if(J1939WordDataConfig[index].attribute&J1939_OFFSET_TYPE)//add 
              {
               dataTemp +=  J1939WordDataConfig[index].offset ;//* scale[dot];
               noSign = 1;  //无符号
               sign = 0;
              } 
              else 
              {
                noSign = 0;
                sign = sign32Bit(&dataTemp,((UINT32)J1939WordDataConfig[index].offset));//* scale[dot]));
              }
              break;
              
              case J1939_ABSOLUTE_VALUE:    //绝对值
                   noSign = 1;  //无符号
                   sign = 0;
                   if(dataTemp)
                   sign32Bit(&dataTemp,((UINT32)J1939WordDataConfig[index].offset));
                   
              break;
              
              
              
        case J1939_SIGNED_DATA_TYPE:
               dot = 0;                  //
               noSign = 0;
               sign = 0;
               switch(J1939Type) 
                  {
                    case J1939_Char_Type   :  if(dataTemp>0x7f){sign = 1;  dataTemp = 0x100- dataTemp; }break;               
                    case J1939_Int_Type    :  if(dataTemp>0x7fff){sign = 1;  dataTemp = 0x10000- dataTemp;}break;
                    case J1939_Three_Type  :  if(dataTemp>0x7fffff){sign = 1; dataTemp = 0x1000000- dataTemp; }break;  
                    case J1939_Word_Type   :  if(dataTemp>0x7fffffff){sign = 1; dataTemp = ((0xffffffff- dataTemp)+1); }break;               
                  };
               break;
         case J1939_FiltrateZero_VALUE:            
               if(J1939WordDataConfig[index].attribute&J1939_OFFSET_TYPE)//add 
                {
                 dataTemp +=  J1939WordDataConfig[index].offset ;//* scale[dot];
                 noSign = 1;  //无符号
                 sign = 0;
                } 
              else 
                {
                   if(dataTemp==0) 
                     {
                        noSign = 0;
                        sign   = 0; 
                     } 
                   else 
                     {
                     
                      noSign = 0;
                      sign = sign32Bit(&dataTemp,((UINT32)J1939WordDataConfig[index].offset));//* scale[dot]));
                     }
                }
                   
              break; 
              case  CLEAN_HIGH_DATA_VALUE: 
              {
                  noSign = 1;  //无符号
                  sign = 0;
                  if(dataTemp>=J1939WordDataConfig[index].thresholdH)
                  dataTemp = 0; 
              }
  
            }
            
            if(!dot && noSign)     //无符号整数
            {
              switch(J1939Type) 
              {
                case J1939_Status_Type :  bit16HexToAscii(pDisBuf,(UINT16)dataTemp);len=5;break;            
                case J1939_Char_Type   :  bit16HexToAscii(pDisBuf,(UINT16)dataTemp);len=5;break;               
                case J1939_Int_Type    :  bit32HexToAscii(pDisBuf,dataTemp);len=10;break;
                case J1939_Three_Type  :  bit32HexToAscii(pDisBuf,dataTemp);len=10;break;  
                case J1939_Word_Type   :  bit32HexToAscii(pDisBuf,dataTemp);len=10;break;               
              };
            }
            else if(!dot && !noSign) //有符号整数
            { 
              switch(J1939Type) 
              {
                case J1939_Status_Type :  bit16HexToAscii(&pDisBuf[1],(UINT16)dataTemp);len=5;break;            
                case J1939_Char_Type   :  bit16HexToAscii(&pDisBuf[1],(UINT16)dataTemp);len=5;break;               
                case J1939_Int_Type    :  bit32HexToAscii(&pDisBuf[1],dataTemp);len=10;break;  
                case J1939_Three_Type  :  bit32HexToAscii(&pDisBuf[1],dataTemp);len=10;break;              
                case J1939_Word_Type   :  bit32HexToAscii(&pDisBuf[1],dataTemp);len=10;break;                
              };               
                pDisBuf[0] = ' ';
                if(sign)                                         
                {
                    pDisBuf[0] = '-';
                }  
                len=len+1;        
            }
            else if(dot && !noSign)  //有符号小数
            {                  
              switch(J1939Type) 
              {
                case J1939_Status_Type :  bit16HexToAscii(&pDisBuf[1],(UINT16)dataTemp);len=5;break;            
                case J1939_Char_Type   :  bit16HexToAscii(&pDisBuf[1],(UINT16)dataTemp);len=5;break;               
                case J1939_Int_Type    :  bit32HexToAscii(&pDisBuf[1],dataTemp);len=10;break;
                case J1939_Three_Type  :  bit32HexToAscii(&pDisBuf[1],dataTemp);len=10;break;                
                case J1939_Word_Type   :  bit32HexToAscii(&pDisBuf[1],dataTemp);len=10;break;                
              };               
                pDisBuf[0] = ' ';
                if(sign)                                         
                {
                    pDisBuf[0] = '-';
                }  
                len=len+1;   
                insertDot(pDisBuf,dot,len); 
                len=len+1;
            } 
            else                                                //无符号小数
            {
              switch(J1939Type) 
                 {
                  case J1939_Status_Type :  bit16HexToAscii(pDisBuf,(UINT16)dataTemp);len=5;break;            
                  case J1939_Char_Type   :  bit16HexToAscii(pDisBuf,(UINT16)dataTemp);len=5;break;               
                  case J1939_Int_Type    :  bit32HexToAscii(pDisBuf,dataTemp);len=10;break; 
                  case J1939_Three_Type  :  bit32HexToAscii(pDisBuf,dataTemp);len=10;break;               
                  case J1939_Word_Type   :  bit32HexToAscii(pDisBuf,dataTemp);len=10;break;               
                };
                 insertDot(pDisBuf,dot,len); 
                 len=len+1;
            }            
                 
        } break; 
      case  DIS_INSIDE_32BIT_TYPE:    //显示32位内部数据
        {
          bit32HexToAscii(pDisBuf,dataTemp);
          len=10; 
          dot = 3;
          insertDot(pDisBuf,dot,len); 
          len=len+1;
        } break;
      /*            // USR_s_DeviceConfigData
        case INSIDE_32BIT_TYPE:    //内部_32
        case 17:
        {   
            bit32HexToAscii(temp,InsidePhys32Bit[index]);
            dot = InsidePhys32BitAttr[index].bitValue >> 0x04;
            insertDot(temp,dot,10);
            asciiToGb2312(&Dis[2*offset],temp,11);
            break;            
        }
        case INSIDE_STATUS_TYPE:     //内部_Status
        case 19:
        {
 //           disMainPageStatus(&Dis[offset],InsidePhysStatusAttr,offset,index,InsidePhysStatus);
            disStatus(&Dis[offset],InsidePhysStatusAttr,offset,index,InsidePhysStatus);
            break;
        }
        case J1939_STATUS_TYPE:      //J1939_Status
        case 14:
        {
            J1939StatusBuf[0] = 0x0c;
            J1939StatusBuf[1] = 0x0a;
            disStatus(&Dis[offset],StatusPrara,offset,index,J1939StatusBuf);
            break;
        } 
        case INSIDE_ASCII_TYPE:     //内部ASCII
        case 18:
        {
            asciiToGb2312(&Dis[2*offset],&InsideAscii[index][0],10);
            break;
        } */
        default:break;   //文字说明
    }  
    return len;
} 

void Display_NoVideoMenu(void)
{	
		OsdCmd(OsdClose);
		VideoChannelSelect(1);
		Osd_Video_Change(Video_State);
		
/*	if(Display_VideoMenu_Flag==1)
	{
		VideoSignalExistOld_Flag=1;
		DelayMs(30);
		Display_VideoMenu_Flag=0;
	}
	if(VideoSignalDetect()==SignalExist)
		VideoSignalExist_Flag=1;
	else
		VideoSignalExist_Flag=0;
	
  if(VideoSignalExist_Flag==0&&VideoSignalExistOld_Flag==1)
  {
		Display_VideoMenu_Flag=1;
		Osd_Video_Change(Osd_State);
		OsdCmd(OsdClose);
		SpiOsdWinAllOff();
		FontOsdWinDisplay(FONT_OSD_ALL_WIN,OFF);
  }
	else if(VideoSignalExistOld_Flag==0&&VideoSignalExist_Flag==1)
	{
		OsdCmd(OsdClose);
		VideoChannelSelect(VideoChannelTemp);
		Osd_Video_Change(Video_State);
	}
	VideoSignalExistOld_Flag=VideoSignalExist_Flag;
	
	///视频不存在
	if(Display_VideoMenu_Flag==1)
	{
		Display_Layer_Graphics
		(&img_NoVideoMenu[VideoChannelTemp],&header_table,&NoVideoMenu_Info,
		&NoVideoMenu_Header,SPI_OSD_WIN_2);
		SpiOsdWinPixelAlpha( SPI_OSD_WIN_2, OFF);

		Display_VideoMenu_Flag=0;
		OsdCmd(OsdOpen);
		SOsdHwBuffWrite2Hw();
	} */
}



/******************************************************************************************
函数名：
******************************************************************************************/


UINT8 Video_cnt;
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/


void construct0(void)
{
	LcdMsg.status.b.disFlag        =CLEAR_PIC_F;
	LcdMsg.flag                 =0;
	/******************添加多页功能**********************/    
	LcdMsg.pageCnt = 1;   //通过按键设置页     
	LcdMsg.osdPage = 1;   //当前页  
	LcdMsg.curPage = 1;
	LcdMsg.picPage = 1;



	
	//TV_POWER1_CTRL //             =1;
	//TV_POWER2_CTRL //             =1;	
	TV_POWER_H;
	disInterfacePic(0x00);
	//	OsdCmd(OsdClose);
	Osd_Video_Change(Osd_State);

	switch(Video_Choose) 
	{
		case RSHIEL_VIDEO_CHANNEL:    	VideoChannelSelect(USR_s_DeviceConfigData.RShieldVideoChannel);break;
		case MIDDLE_DOOR_VIDEO_CHANNEL: VideoChannelSelect(USR_s_DeviceConfigData.MiddleDoorVideoChannel);break;      
		case FRONT_DOOR_VIDEO_CHANNEL:  VideoChannelSelect(USR_s_DeviceConfigData.FrontDoorVideoChannel);break;       
		case TOP_VIDEO_CHANANEL:        VideoChannelSelect(USR_s_DeviceConfigData.TopVideoChannel);break;      	  
	};

	DelayMs(10);		
	Osd_Video_Change(Video_State);	 
	OsdCmd(OsdOpen); 
	ExitMenuNum = 1;
	Video_cnt = 0;

}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc0(LCD_MSG  *pMsg)
{  
   UINT8 flag;
   
   if(pMsg->flag & EXIT_KEY)
   { 
       pMsg->flag = 0x00;
       return ExitMenuNum;
   } 
   else if(pMsg->flag & SILENCE_KEY)
    {
        pMsg->flag = 0;
      //return 0x02;
    } 
   
    flag = VideoSignalDetect();
    if(flag==0)
     {
       Video_cnt++; 
       if(Video_cnt>20) Video_cnt = 20;
    }
    if(flag)
      {
        Video_cnt = 0;
        LcdMsg.status.b.disFlag=CLEAR_PIC_F;     //1->有信号  0-无信号  
      }
	if(Video_cnt==20) 
	{  
		//else 
		LcdMsg.status.b.disFlag=SHOW_PIC_F;
	}
   	LcdMsg.cursor  = Video_Choose;


   if(pMsg->flag & R_GEAR_KEY)                      //倒档视频切换
   {
        pMsg->flag = 0x00;
        Video_Choose =  RSHIEL_VIDEO_CHANNEL;
        Osd_Video_Change(Osd_State);
       	VideoChannelSelect(USR_s_DeviceConfigData.RShieldVideoChannel);
       	DelayMs(20);
       	Osd_Video_Change(Video_State);  
       	LcdMsg.status.b.disFlag=CLEAR_PIC_F;    
   } 
   else if((pMsg->flag & MIDDLE_DOOR_OPEN_KEY)&&(R_GEAR_VIDEO_LOAD==0))
   {
        pMsg->flag = 0x00;
        Video_Choose =  MIDDLE_DOOR_VIDEO_CHANNEL;
        Osd_Video_Change(Osd_State);
       	VideoChannelSelect(USR_s_DeviceConfigData.MiddleDoorVideoChannel);
       	DelayMs(20);
       	Osd_Video_Change(Video_State);
       	LcdMsg.status.b.disFlag=CLEAR_PIC_F;    
   }                                      // zh 
    else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
     //  return 21;
   }  
   else if(pMsg->flag&R_GEAR_OVER_KEY) 
    {
        if(MIDDLE_VIDEO_LOAD==0) 
        {
          pMsg->flag = 0x00;
          return 1;
        }
        else 
        {
          pMsg->flag = 0x00;
          Video_Choose =  MIDDLE_DOOR_VIDEO_CHANNEL;
          Osd_Video_Change(Osd_State);
         	VideoChannelSelect(USR_s_DeviceConfigData.MiddleDoorVideoChannel);
         	DelayMs(20);
         	Osd_Video_Change(Video_State);
         	LcdMsg.status.b.disFlag=CLEAR_PIC_F;  
         
        }
    
    }
   else if((pMsg->flag==MIDDLE_DOOR_OPEN_OVER_KEY)&&(R_GEAR_VIDEO_LOAD==0))  //倒档视频关 中门视频关   //&&()
   {
         pMsg->flag = 0x00;
         return 1; 
   } 
   else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       if(Video_Choose==MIDDLE_DOOR_VIDEO_CHANNEL) 
       { 
        Video_Choose = RSHIEL_VIDEO_CHANNEL;
       	VideoChannelSelect(USR_s_DeviceConfigData.RShieldVideoChannel);  
       }
       else 
       {  
        Video_Choose =  MIDDLE_DOOR_VIDEO_CHANNEL;
       	VideoChannelSelect(USR_s_DeviceConfigData.MiddleDoorVideoChannel);  
       }
       
    } 
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }

   doInterfacePiclogic(0,1,pMsg->pageCnt);  
   return 0x00;
   
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：视频界面
******************************************************************************************/
void deconstruct0(void)
{
   // TV_POWER1_CTRL  ;        //    =0;
 	 // TV_POWER2_CTRL ;      //       =0;
 	 TV_POWER_L;
 	  Osd_Video_Change(Osd_State);
}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无页
返回值：无
******************************************************************************************/
void construct1(void)
{
    UINT8 i;
    disInterfacePic(0x01);
    LcdMsg.cursor = 0;  //初始化光标位置
    LcdMsg.menuOne = 1; //光标位置初始化
    LcdMsg.menuTwo = 1;
    LcdMsg.status.b.disFlag=SHOW_PIC_F;
/******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页    
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.picPage = 1;
    LcdMsg.curPage = 1;
    
    for(i=0;i<3;i++) OsdLeddisBuf[i]=0x00;   
    ExitMenuNum = 2;
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 RefreshCnt_100ms = 0;
UINT8 msgProc1(LCD_MSG  *pMsg)
{
	static UINT8 clearRelativeCnt=0; 
	UINT8 cnt,i;

	UINT16 keyIndex = pMsg->flag;
	if(keyIndex & EXIT_KEY)
	{
		pMsg->flag = 0;
		return ExitMenuNum;
	}
    else if(keyIndex & SILENCE_KEY)
    {
         pMsg->flag = 0;
      //return 0x02;
    } 
    else if(keyIndex & DOWN_KEY)
	{
		pMsg->flag = 0;
		clearRelativeCnt++;
		if(clearRelativeCnt>=3) 
		{
			if(USR_s_DeviceConfigData.maintain==0) 
			{
				USR_s_DeviceConfigData.maintain = 1;
				MaintainClear_F = 0;
				PowerOffSave();
			}
		}
		//return 0x02;
	}
	else if(pMsg->flag & R_GEAR_KEY)
	{
		pMsg->flag = 0x00;
		Video_Choose = RSHIEL_VIDEO_CHANNEL;
		return 0;        
	}
	else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
	{
	   pMsg->flag = 0x00;
	   Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
	   return 0;
	}
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
     //  return 21;
   }
    else if(keyIndex & VIDEO_KEY)   //
    {
		pMsg->flag = 0;
		Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
		return 0x00;
    }
    else if(keyIndex & ENTER_KEY) 
    {
		clearRelativeCnt++;
		if(clearRelativeCnt>=2) 
		{
			//clearRelativeCnt = 0;
			if(USR_s_DeviceConfigData.RelativeDistance) 
			{   
				USR_s_DeviceConfigData.RelativeDistance = 0;
				ClearRelativeDistance_F = 0;
				PowerOffSave();
			}
		}
		pMsg->flag = 0;
    } 
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     if(_1S_DIS_F)
     {
		clearRelativeCnt = 0;
		_1S_DIS_F = 0;
		if(dis_count)pMsg->cursor++;
		if(pMsg->cursor>=dis_count) pMsg->cursor=0; 
		// 
     } 
	 
	 if((RefreshCnt_100ms == 2)||(RefreshCnt_100ms == 5)||(RefreshCnt_100ms == 8)){
	 	static UINT8 oldStatus = 0xff;
		if(oldStatus != RefreshCnt_100ms){
			oldStatus= RefreshCnt_100ms;
			i = RefreshCnt_100ms/3;
			OsdLeddisBuf[i]=~OsdLedStatus[i];  
		}

	 }
	 
	 
     for(cnt=0;cnt<3;cnt++)
     	OsdLedStatus[cnt] = LogicOutPut[cnt+1].Load; // 1-3


	disLed(OsdLedStatus);  
	doInterfacePiclogic(1,0,pMsg->pageCnt);
	doInterfaceOsdlogic(1,pMsg->pageCnt);
	
    return 0x01;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct1(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造故障查询界面
参数说明：无
返回值：无
******************************************************************************************/
void construct2(void)
{
    UINT8 i;
    LcdMsg.cursor =  LcdMsg.menuOne;   //还原一级光标位置
    LcdMsg.menuTwo = 1;                //初始化二级菜单光标位置
   	LcdMsg.status.b.disFlag=SHOW_PIC_F;               //默认选中
   	/******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页
    LcdMsg.curPage = 1;  
    disInterfacePic(0x02);  	
    for(i=0;i<16;i++)    MenuConfig[i] = 0;
    ExitMenuNum = 1;
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：构造故障查询任务处理
******************************************************************************************/
UINT8 msgProc2(LCD_MSG  *pMsg)
{
    if(pMsg->flag & ENTER_KEY)
    {
     pMsg->flag = 0;
     pMsg->menuOne = pMsg->cursor;//保存一级菜单光标位置
     switch(pMsg->cursor) 
     {
       case 1:  if(MenuConfig[0]>2){ExitMenuNum = 2;  return MenuConfig[0];}break;
       case 2:  if(MenuConfig[1]>2){ExitMenuNum = 2;  return MenuConfig[1];}break;
       case 3:  if(MenuConfig[2]>2){ExitMenuNum = 2;  return MenuConfig[2];}break;
       case 4:  if(MenuConfig[3]>2){ExitMenuNum = 2;  return MenuConfig[3];}break;
       case 5:  if(MenuConfig[4]>2){ExitMenuNum = 2;  return MenuConfig[4];}break;
       case 6:  if(MenuConfig[5]>2){ExitMenuNum = 2;  return MenuConfig[5];}break;
       case 7:  if(MenuConfig[6]>2){ExitMenuNum = 2;  return MenuConfig[6];}break;
       case 8:  if(MenuConfig[7]>2){ExitMenuNum = 2;  return MenuConfig[7];}break;    
      default:break;
     }
    }
    else if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;
    } 
    else if(pMsg->flag & VIDEO_KEY)
    {
       pMsg->flag = 0;
        Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag & SILENCE_KEY)
    {
       pMsg->flag = 0; 
      //  return 0x04;
    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->cursor<200)
         pMsg->cursor++;
         pMsg->flag = 0; 
    } 
    else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor!=0) 
      {
        pMsg->cursor-- ; 
      }
           pMsg->flag = 0; 
    }
    else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
     //  return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(2,3,pMsg->pageCnt);
     doInterfaceOsdlogic(2,pMsg->pageCnt);
    return 0x02;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct2(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct3(void)
{
    LcdMsg.status.b.disFlag=SHOW_PIC_F;   //默认选中
    LcdMsg.dataTemp =0xff;
    LcdMsg.cursor = 0;     //光标位置初始化   
   	
 	/******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页
    LcdMsg.curPage = 1;         
    disInterfacePic(0x03);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc3(LCD_MSG  *pMsg)
{
   //  UINT8 eerNumber[3],page;
  //   UINT16 dis_count_temp;
    if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if(dis_count<=ONE_PAGE_ITEM);
        else if(pMsg->cursor<dis_count-ONE_PAGE_ITEM) 
        {
         pMsg->cursor+=ONE_PAGE_ITEM;
        }
         pMsg->flag = 0; 
    } 
    else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor>=ONE_PAGE_ITEM) 
      {
        pMsg->cursor-=ONE_PAGE_ITEM; 
      } 
      else
      {
        pMsg->cursor=0;
      }
          pMsg->flag = 0; 
    }
    else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
     //  return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
   
     doInterfacePiclogic(3,1,pMsg->pageCnt);
     doInterfaceOsdlogic(3,pMsg->pageCnt);
    return 0x03;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct3(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct4(void)
{
    UINT8 i;
    LcdMsg.status.b.disFlag=SHOW_PIC_F;           //默认选中
    LcdMsg.cursor = LcdMsg.menuTwo; //光标位置初始化
  	/******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.curPage = 1;  
    disInterfacePic(0x04);
    for(i=0;i<16;i++)    MenuConfig[i] = 0;
    ExitMenuNum = 2;
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc4(LCD_MSG  *pMsg)
{   
    if(pMsg->flag & EXIT_KEY)
    {
      pMsg->flag = 0;

      return ExitMenuNum;   

    } 
    else if(pMsg->flag & VIDEO_KEY)
    {
         pMsg->flag = 0;
         Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
        return 0x00;
    }
    else if(pMsg->flag & SILENCE_KEY)
    {
          pMsg->flag = 0;
        //return 0x00;
    }
   else if(pMsg->flag & ENTER_KEY)
    {
       LcdMsg.menuTwo = LcdMsg.cursor; //保存二级菜单光标位置
       pMsg->flag = 0;
       switch(pMsg->cursor) 
       {
       case 1:  if(MenuConfig[0]>2){ExitMenuNum = 4;  return MenuConfig[0];}break;
       case 2:  if(MenuConfig[1]>2){ExitMenuNum = 4;  return MenuConfig[1];}break;
       case 3:  if(MenuConfig[2]>2){ExitMenuNum = 4;  return MenuConfig[2];}break;
       case 4:  if(MenuConfig[3]>2){ExitMenuNum = 4;  return MenuConfig[3];}break; 
       case 5:  if(MenuConfig[4]>2){ExitMenuNum = 4;  return MenuConfig[4];}break;
       case 6:  if(MenuConfig[5]>2){ExitMenuNum = 4;  return MenuConfig[5];}break;
       case 7:  if(MenuConfig[6]>2){ExitMenuNum = 4;  return MenuConfig[6];}break;
       case 8:  if(MenuConfig[7]>2){ExitMenuNum = 4;  return MenuConfig[7];}break;    
        default:break;
       }

    }
   else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->cursor<200)
         pMsg->cursor++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor!=0) 
      {
        pMsg->cursor-- ; 
      }
         pMsg->flag = 0; 
    }	
      else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
     //  return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }   
      doInterfacePiclogic(4,2,pMsg->pageCnt);
      doInterfaceOsdlogic(4,pMsg->pageCnt);
    return 0x04;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct4(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
   
******************************************************************************************/
void DisplaySystemTimeSet(UINT8 addrDate,UINT8 color,UINT8 blinkflag,UINT8 blinkBit) 
{
  UINT8 Time_Display[20],i;
  if(M41t00StopFlag==0) 
  { 
     for(i=0;i<6;i++)
    {
        TimeElement[2*i]   = RealTimeCnt[i] >> 0x04;
        TimeElement[2*i+1] = RealTimeCnt[i] & 0x0f;
    }    
  }
  Time_Display[0]  = '2';
  Time_Display[1] = '0'; 
  Time_Display[2] = TimeElement[0]+'0';
  Time_Display[3] = TimeElement[1]+'0';
  Time_Display[4] = '-'; 
  Time_Display[5] = TimeElement[2]+'0';
  Time_Display[6] = TimeElement[3]+'0';
  Time_Display[7] = '-';
  Time_Display[8] = TimeElement[4]+'0';
  Time_Display[9] = TimeElement[5]+'0';
  Time_Display[10] = ' ';
    
  Time_Display[11] = TimeElement[6]+'0';
  Time_Display[12] = TimeElement[7]+'0';
  Time_Display[13] = ':'; 
  Time_Display[14] = TimeElement[8]+'0';
  Time_Display[15] = TimeElement[9]+'0';
  Time_Display[16] = ':';
  Time_Display[17] = TimeElement[10]+'0';
  Time_Display[18] = TimeElement[11]+'0';
  
  if(blinkBit>9) blinkBit= blinkBit+5;
  else if(blinkBit>7) blinkBit= blinkBit+4; 
  else if(blinkBit>5) blinkBit= blinkBit+3; 
  else if(blinkBit>3) blinkBit= blinkBit+2;       
  else if(blinkBit>1) blinkBit= blinkBit+1; 
  	for(i=0;i<19;i++)
	{                             
		if(i==blinkBit+2&&blinkflag) 
			 WriteColor_StringToAddr(addrDate+i, color,&Time_Display[i],1,1);
		else
			 WriteColor_StringToAddr(addrDate+i, color,&Time_Display[i],1,0);
	}   
}
/******************************************************************************************
函数名：UINT8 timeCheck(void)
功能：检测日期时间是否正确
返回值：正确:0x00
        错误:0x01
******************************************************************************************/
UINT8 timeCheck(void)
{
    UINT16 year = 2000 + TimeElement[YEAR_H]*10 + TimeElement[YEAR_L];
    UINT8 month = TimeElement[MONTH_H]*10 + TimeElement[MONTH_L];
    UINT8 date = TimeElement[DATE_H]*10 + TimeElement[DATE_H];
    if((TimeElement[MONTH_H] > 0x01) || ((TimeElement[MONTH_H]==0x01) && (TimeElement[MONTH_L]>0x02)))
    {
        return TIME_CHECK_ERROR;
    }
    if(date > month_n_day(year, month))
    {
        return TIME_CHECK_ERROR;
    }
    if((TimeElement[HOUR_H]>0x02) || ((TimeElement[HOUR_H]==0x02) && (TimeElement[HOUR_L]>0x04)))
    {
        return TIME_CHECK_ERROR;
    }
    if(TimeElement[MINUTE_H] > 0x06)
    {
        return TIME_CHECK_ERROR; 
    }
    if(TimeElement[SECOND_H] > 0x06)
    {
        return TIME_CHECK_ERROR;
    }
    return TIME_CHECK_TRUE;
}

void construct5(void)
{	
    UINT8 i;
    LcdMsg.interfaceCnt = 0;
    LcdMsg.status.b.disFlag = SHOW_PIC_F;  //不选中
    M41t00StopFlag = 0; 	
   	LcdMsg.cursor = 1;         //页计数  由于有加减按键  所以从一开始
   	LcdMsg.dataTemp = 0;       //用作输入选中
  	LcdMsg.interfaceCnt = 0;   //设置时间用
  	/******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.curPage = 1; 
    
    disInterfacePic(0x05);

    for(i=0;i<6;i++)
    {
        TimeElement[2*i]   = RealTimeCnt[i] >> 0x04;
        TimeElement[2*i+1] = RealTimeCnt[i] & 0x0f;
    }
  	if(USR_s_DeviceConfigData.Wippers >9 || USR_s_DeviceConfigData.Wippers < 5)
		{
		    USR_s_DeviceConfigData.Wippers = 5;
		} 
  	if(USR_s_DeviceConfigData.LightLevel >3 || USR_s_DeviceConfigData.LightLevel < 1)
	{
	    USR_s_DeviceConfigData.LightLevel = 1;
	} 
	if(USR_s_DeviceConfigData.BuzzerLevel >3 || USR_s_DeviceConfigData.BuzzerLevel < 1)
	{
	    USR_s_DeviceConfigData.BuzzerLevel = 1;
	} 
}
const UINT8 TimeMax[12] = {0x09,0x09,0x01,0x09,0x03,0x09,0x02,0x09,0x05,0x09,0x05,0x09};
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：  参数设定
******************************************************************************************/
UINT8 msgProc5(LCD_MSG  *pMsg)
{
   UINT8 dataTemp;
   if(pMsg->flag & EXIT_KEY) 
   {
         pMsg->flag = 0;
         if(pMsg->dataTemp==0) 
         {
			  PowerOffSave();
			  USR_s_OV.rain_scr = USR_s_DeviceConfigData.Wippers; 
			  return ExitMenuNum;
         } 
         else 
         {
           if(pMsg->cursor==4) 
           {
               pMsg->interfaceCnt++;
               if(pMsg->interfaceCnt>=12)  
               		pMsg->interfaceCnt=0;
           }
         }
   }
   else if(pMsg->flag & ENTER_KEY)
    { 
       pMsg->flag = 0;
       if(pMsg->dataTemp==0) 
       {
          
         pMsg->dataTemp = 1;  //输入选中
       	 M41t00StopFlag = 0;
       }
       else 
       {
        if(M41t00StopFlag==1) 
        {  
          //  if(timeCheck()==TIME_CHECK_TRUE)
           {
              TimeSet();
             M41t00StopFlag = 0;
             pMsg->interfaceCnt = 0;
             pMsg->dataTemp=0;   //输入不选中
           } 
          // else 
          // {
          //    pMsg->dataTemp=1;   //输入选中
          // }
        }
        else 
        {
           pMsg->interfaceCnt = 0;
           pMsg->dataTemp=0;   //输入不选中
        }
       } 
    }
      else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
    //   return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
    
    
    if(pMsg->dataTemp==1)  //选中
    { 
           if(pMsg->flag & DOWN_KEY) 
              {
                   if(pMsg->cursor==1) 
                   {
                     if(USR_s_DeviceConfigData.Wippers <= WIPERS_MIN_TIME)
                      {
                          USR_s_DeviceConfigData.Wippers = WIPERS_MAX_TIME;
                      }
                      else
                      {
                          USR_s_DeviceConfigData.Wippers--;
                      }
                     
                   } 
                   else if(pMsg->cursor==2) 
                   {
                        if(USR_s_DeviceConfigData.LightLevel<=LIGHT_MIN_LEVEL) 
                        {
                          USR_s_DeviceConfigData.LightLevel = LIGHT_MAX_LEVEL;
                        }
                        else USR_s_DeviceConfigData.LightLevel--;
                        
                   }
                   else if(pMsg->cursor==3) 
                   {
                       if(USR_s_DeviceConfigData.BuzzerLevel<=BUZZER_MIN_LEVEL) 
                       {
                        USR_s_DeviceConfigData.BuzzerLevel =  BUZZER_MAX_LEVEL;
                       }
                       else  USR_s_DeviceConfigData.BuzzerLevel--;
                   } 
                   else if(pMsg->cursor==4) 
                    {
                     M41t00StopFlag = 1;
                    if(!TimeElement[pMsg->interfaceCnt])
                     {
                         TimeElement[pMsg->interfaceCnt] = TimeMax[pMsg->interfaceCnt];
                     }
                     else
                     {
                         TimeElement[pMsg->interfaceCnt]--;
                     } 
                    }
                    pMsg->flag = 0; 
                 }
               else if(pMsg->flag &UP_KEY) 
              {
                    if(pMsg->cursor==1) 
                    { 
                        if(USR_s_DeviceConfigData.Wippers >= WIPERS_MAX_TIME)
                        {
                            USR_s_DeviceConfigData.Wippers = WIPERS_MIN_TIME;
                        }
                        else
                        {
                            USR_s_DeviceConfigData.Wippers++;
                        }
                           
                    }
                     if(pMsg->cursor==2) 
                     {
                         
                         if(USR_s_DeviceConfigData.LightLevel>=LIGHT_MAX_LEVEL) 
                         USR_s_DeviceConfigData.LightLevel=LIGHT_MIN_LEVEL;
                         else USR_s_DeviceConfigData.LightLevel++;
                     }
                      if(pMsg->cursor==3) 
                      {
                        if(USR_s_DeviceConfigData.BuzzerLevel>=BUZZER_MAX_LEVEL) 
                        USR_s_DeviceConfigData.BuzzerLevel=BUZZER_MIN_LEVEL;
                        else USR_s_DeviceConfigData.BuzzerLevel++;
                        pMsg->flag = 0; 
                      } 
                     if(pMsg->cursor==4) 
                      { 
                         M41t00StopFlag = 1;
                         if(TimeElement[pMsg->interfaceCnt] < TimeMax[pMsg->interfaceCnt])
                         {
                             TimeElement[pMsg->interfaceCnt]++; 
                         }
                         else
                         {
                             TimeElement[pMsg->interfaceCnt] = 0x00;
                         }         
                      }  
                    pMsg->flag = 0; 
              }      
                    
           dataTemp  = USR_s_DeviceConfigData.Wippers+'0';
           if(pMsg->cursor==1)
           WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,1);
           else  WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,0);
           dataTemp  = USR_s_DeviceConfigData.LightLevel+'0';
            if(pMsg->cursor==2)
           WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,1);
           else  WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,0);
           dataTemp  = USR_s_DeviceConfigData.BuzzerLevel +'0';
            if(pMsg->cursor==3)
           WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,1);
           else WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,0);
            if(pMsg->cursor==4)
           DisplaySystemTimeSet(3,0x34,1,pMsg->interfaceCnt); 
            else   DisplaySystemTimeSet(3,0x34,0,0); 
           
          }
     else    //不选中
    {
          if(pMsg->flag & DOWN_KEY) 
          {
              if( pMsg->cursor<200)
               pMsg->cursor++;
               pMsg->flag = 0; 
          } 
         else if(pMsg->flag &UP_KEY) 
          {
            if(pMsg->cursor!=0) 
            {
              pMsg->cursor-- ; 
            }
               pMsg->flag = 0; 
          }
           dataTemp  = USR_s_DeviceConfigData.Wippers+'0'; 
           WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,0);// 雨刮
           dataTemp  = USR_s_DeviceConfigData.LightLevel+'0';
           WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,0);//背光
           dataTemp  = USR_s_DeviceConfigData.BuzzerLevel +'0';
           WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,0);//蜂鸣器
           DisplaySystemTimeSet(3,0x34,0,0);
    }
 
        doInterfacePiclogic(5,2,pMsg->pageCnt);
        doInterfaceOsdlogic(5,pMsg->pageCnt); 

    return 0x05;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct5(void)
{
	//PowerOffSave();
}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct6(void)
{

    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   	LcdMsg.dataTemp = 0;       //用作输入选中
   
   	if(USR_s_DeviceConfigData.RShieldVideoChannel > 3)
		{
		    USR_s_DeviceConfigData.RShieldVideoChannel = 0x00;
		}
		if(USR_s_DeviceConfigData.MiddleDoorVideoChannel > 3)
		{
		    USR_s_DeviceConfigData.MiddleDoorVideoChannel = 0x00;
		}
		if(USR_s_DeviceConfigData.FrontDoorVideoChannel> 3)                                    
		{
		    USR_s_DeviceConfigData.FrontDoorVideoChannel = 0x00;
		}
		if(USR_s_DeviceConfigData.TopVideoChannel > 3)
		{
		    USR_s_DeviceConfigData.TopVideoChannel = 0x00;
		}
		TV_POWER_H;
		
 	  /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    disInterfacePic(6);
    
    

}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
	UINT8 msgProc6(LCD_MSG	*pMsg)
	{
	 UINT8 dataTemp;
	  if(pMsg->flag & EXIT_KEY)
		{
		  pMsg->flag = 0;
		  if(pMsg->dataTemp==0) 
		  {
			PowerOffSave();
			return ExitMenuNum;
		  }
		}
		else if(pMsg->flag & ENTER_KEY)
		{ 
		   pMsg->flag = 0;
		   if(pMsg->dataTemp==0) 
		   {  
			 pMsg->dataTemp = 1;  //输入选中
		   }
		   else 
		   {
			pMsg->dataTemp = 0; 
			Osd_Video_Change(Osd_State);
		   } 
		}
		   else if(pMsg->flag & R_GEAR_KEY)
		{
		   pMsg->flag = 0x00;
		   Video_Choose = RSHIEL_VIDEO_CHANNEL;
		   return 0;		
		}
	   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
	   {
		   pMsg->flag = 0x00;
		   Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
		   return 0;
	   }
	   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
	   {
		   pMsg->flag = 0x00;
		  // return 21;
	   }
		else if(pMsg->flag & VIDEO_KEY)   //
		{
		   pMsg->flag = 0;
		   Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
		   return 0x00;
		}
		else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
		{
			pMsg->flag = 0x00;
		   return 21;
		}
		if(pMsg->dataTemp==1)  //选中
		{ 
			   if(pMsg->flag & DOWN_KEY) 
				  {
					   if(pMsg->cursor==1) 
					   {
							if (USR_s_DeviceConfigData.FrontDoorVideoChannel < 3)
							  USR_s_DeviceConfigData.FrontDoorVideoChannel++;
							else
							  USR_s_DeviceConfigData.FrontDoorVideoChannel = 0;
							  Osd_Video_Change(Osd_State);
							
							VideoChannelSelect(USR_s_DeviceConfigData.FrontDoorVideoChannel);
							WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,1);
							DelayMs(30);  
							Osd_Video_Change(Video_State); 
						   
					   } 
					   else if(pMsg->cursor==2) 
					   {
							if (USR_s_DeviceConfigData.MiddleDoorVideoChannel < 3)
							  USR_s_DeviceConfigData.MiddleDoorVideoChannel++;
							else
							  USR_s_DeviceConfigData.MiddleDoorVideoChannel = 0;
							
							  Osd_Video_Change(Osd_State);
							 
							  
							  VideoChannelSelect(USR_s_DeviceConfigData.MiddleDoorVideoChannel);  
							WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,1);
							
							DelayMs(30);  
							Osd_Video_Change(Video_State); 
										 
					   }
					   else if(pMsg->cursor==3) 
					   {
							if (USR_s_DeviceConfigData.RShieldVideoChannel < 3)
							  USR_s_DeviceConfigData.RShieldVideoChannel++;
							else
							  USR_s_DeviceConfigData.RShieldVideoChannel = 0;
							   Osd_Video_Change(Osd_State);
							  
							  VideoChannelSelect(USR_s_DeviceConfigData.RShieldVideoChannel);
							  
							 
							WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,1);  
						   
							DelayMs(30);;
							Osd_Video_Change(Video_State); 
							
	
					   } 
					   else if(pMsg->cursor==4) 
						{
							if (USR_s_DeviceConfigData.TopVideoChannel < 3)
							  USR_s_DeviceConfigData.TopVideoChannel++;
							else
							  USR_s_DeviceConfigData.TopVideoChannel = 0;
							 Osd_Video_Change(Osd_State);
							 
								VideoChannelSelect(USR_s_DeviceConfigData.TopVideoChannel);
								
							  
							 
							WriteColor_StringToAddr(3,0x30|CH_COLOR_RED,&dataTemp,1,1);
							
							 DelayMs(30);
							Osd_Video_Change(Video_State);	
						 
	
						}
							   // DelayMs(20);
								
							//	DelayMs(3);  
					   pMsg->flag = 0;
					 }
				  else if(pMsg->flag &UP_KEY) 
				  {
						if(pMsg->cursor==1) 
						{ 
							if (USR_s_DeviceConfigData.FrontDoorVideoChannel == 0)
							  USR_s_DeviceConfigData.FrontDoorVideoChannel = 3;
							else
							  USR_s_DeviceConfigData.FrontDoorVideoChannel--;	
							  Osd_Video_Change(Osd_State);
							 
								VideoChannelSelect(USR_s_DeviceConfigData.FrontDoorVideoChannel);
								 
							  
							  
							WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,1);
							DelayMs(30);
							 Osd_Video_Change(Video_State); 
						  
						  
						}
						 if(pMsg->cursor==2) 
						 {	 
							if (USR_s_DeviceConfigData.MiddleDoorVideoChannel == 0)
							  USR_s_DeviceConfigData.MiddleDoorVideoChannel = 3;
							else
							  USR_s_DeviceConfigData.MiddleDoorVideoChannel--;
								VideoChannelSelect(USR_s_DeviceConfigData.MiddleDoorVideoChannel);
						  
							  Osd_Video_Change(Osd_State);
							  
							WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,1);  
							DelayMs(30);
							Osd_Video_Change(Video_State);
						  
						   
						   
						 }
						  if(pMsg->cursor==3) 
						  {
							if (USR_s_DeviceConfigData.RShieldVideoChannel == 0)
							  USR_s_DeviceConfigData.RShieldVideoChannel = 3;
							else
							  USR_s_DeviceConfigData.RShieldVideoChannel--;
							  VideoChannelSelect(USR_s_DeviceConfigData.RShieldVideoChannel);
							
							  Osd_Video_Change(Osd_State);
							
							WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,1);
							DelayMs(30); 
							Osd_Video_Change(Video_State);	
							
						
						
						 
						  } 
						 if(pMsg->cursor==4) 
						  { 
							if (USR_s_DeviceConfigData.TopVideoChannel == 0)
							  USR_s_DeviceConfigData.TopVideoChannel = 3;
							else
							  USR_s_DeviceConfigData.TopVideoChannel--;
								VideoChannelSelect(USR_s_DeviceConfigData.TopVideoChannel);
							
							
							  Osd_Video_Change(Osd_State);
							 
							WriteColor_StringToAddr(3,0x30|CH_COLOR_RED,&dataTemp,1,1);  
							DelayMs(30);
							Osd_Video_Change(Video_State);	
						   } 
							pMsg->flag = 0;
				  }
						
			   dataTemp  = USR_s_DeviceConfigData.FrontDoorVideoChannel+'0';
			   if(pMsg->cursor==1) 
			   {
				WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,1);  
			   }
				else  WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,0);  
				
			   dataTemp  = USR_s_DeviceConfigData.MiddleDoorVideoChannel+'0';
				if(pMsg->cursor==2) 
				{	 
				WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,1);
				}
			   else  WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,0);
				  
				  
				
			   dataTemp  = USR_s_DeviceConfigData.RShieldVideoChannel +'0';
			   
				if(pMsg->cursor==3) 
				{
				  
				WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,1);
	
				}
			   else WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,0);
			   dataTemp  = USR_s_DeviceConfigData.TopVideoChannel+'0';
			   if(pMsg->cursor==4) 
			   { 
	
				WriteColor_StringToAddr(3,0x30|CH_COLOR_RED,&dataTemp,1,1);
			   }
			   else  WriteColor_StringToAddr(3,0x30|CH_COLOR_RED,&dataTemp,1,0); 
			  }
		 else	 //不选中
		{
			  
			  if(pMsg->flag & DOWN_KEY) 
			  {
				  if( pMsg->cursor<200)
				   pMsg->cursor++;
				   pMsg->flag = 0; 
			  } 
			 else if(pMsg->flag &UP_KEY) 
			  {
				if(pMsg->cursor!=0) 
				{
				  pMsg->cursor-- ; 
				}
				   pMsg->flag = 0; 
			  }
			   dataTemp  = USR_s_DeviceConfigData.FrontDoorVideoChannel+'0'; 
			   WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,0);
			   dataTemp  = USR_s_DeviceConfigData.MiddleDoorVideoChannel+'0';
			   WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,0);
			   dataTemp  = USR_s_DeviceConfigData.RShieldVideoChannel +'0';
			   WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,0);
			   dataTemp  = USR_s_DeviceConfigData.TopVideoChannel +'0';
			   WriteColor_StringToAddr(3,0x30|CH_COLOR_RED,&dataTemp,1,0);
		  
		}
		 doInterfacePiclogic(6,2,pMsg->pageCnt);
		 doInterfaceOsdlogic(6,pMsg->pageCnt);
		return 6;
	   
	   
	}

/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct6(void)
{
	 
	  TV_POWER_L;
	Osd_Video_Change(Osd_State);
	OsdCmd(OsdOpen); 
}

/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct7(void)
{
    LcdMsg.status.b.disFlag=SHOW_PIC_F;    //默认选中
   	LcdMsg.cursor = 1;      //页计数  由于有加减按键  所以从一开始
    LcdMsg.cursor = LcdMsg.menuTwo;
	 /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页
    LcdMsg.curPage = 1;  
   disInterfacePic(0x07);
   ExitMenuNum = 2;
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc7(LCD_MSG  *pMsg)
{

   if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->cursor<200)
         pMsg->cursor++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor!=0) 
      {
        pMsg->cursor-- ; 
      }
         pMsg->flag = 0; 
    }	 
   else if(pMsg->flag & VIDEO_KEY)
    {
         pMsg->flag = 0;
    }
    else if(pMsg->flag & SILENCE_KEY)
    {
          pMsg->flag = 0;
    }
   else if(pMsg->flag & ENTER_KEY)
    {
       LcdMsg.menuTwo = LcdMsg.cursor; //保存二级菜单光标位置
       pMsg->flag = 0;
      /* switch(pMsg->cursor) 
       {
        case 1: return 23; break;  //通道设置
        case 2: return 24; break;  //画面设置
        case 3: return 25; break;  //通道设置
        case 4: return 26; break;  //画面设置
        default:break;
       }  */      
     switch(pMsg->cursor) 
     {
       case 1:  if(MenuConfig[0]>2){ExitMenuNum = 7;  return MenuConfig[0];}break;
       case 2:  if(MenuConfig[1]>2){ExitMenuNum = 7;  return MenuConfig[1];}break;
       case 3:  if(MenuConfig[2]>2){ExitMenuNum = 7;  return MenuConfig[2];}break;
       case 4:  if(MenuConfig[3]>2){ExitMenuNum = 7;  return MenuConfig[3];}break;
       case 5:  if(MenuConfig[4]>2){ExitMenuNum = 7;  return MenuConfig[4];}break;
       case 6:  if(MenuConfig[5]>2){ExitMenuNum = 7;  return MenuConfig[5];}break;
       case 7:  if(MenuConfig[6]>2){ExitMenuNum = 7;  return MenuConfig[6];}break;
       case 8:  if(MenuConfig[7]>2){ExitMenuNum = 7;  return MenuConfig[7];}break; 
      default:break;
     }

    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }

   
   
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
     //  return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(7,2,pMsg->pageCnt);
     doInterfaceOsdlogic(7,pMsg->pageCnt);
    return 0x07;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct7(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct8(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    disInterfacePic(0x08);
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    LcdMsg.cursor = 0; //光标位置初始化
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc8(LCD_MSG  *pMsg)
{
 if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;
    } 
   else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
         LcdMsg.dataTemp = 0;
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
         LcdMsg.dataTemp = 0;
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00; //return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }	
     doInterfacePiclogic(8,0,pMsg->pageCnt);   
     doInterfaceOsdlogic(8,pMsg->pageCnt);

    return 8;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct8(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct9(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    disInterfacePic(0x09);
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.curPage = 1; 
    LcdMsg.cursor = 0; //光标位置初始化
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc9(LCD_MSG  *pMsg)
{
    if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;
    }
    else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    } 
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
   else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
         LcdMsg.dataTemp = 0;
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
         LcdMsg.dataTemp = 0;
    }
     doInterfacePiclogic(9,0,pMsg->pageCnt);
     doInterfaceOsdlogic(9,pMsg->pageCnt);
    return 0x09;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct9(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct10(void)
{    
      LcdMsg.status.b.disFlag = SHOW_PIC_F;
      LcdMsg.cursor = 1; //光标位置初始化
      LcdMsg.dataTemp=0;
      LcdMsg.dataCnt = 0;
     /******************添加多页功能**********************/    
      LcdMsg.pageCnt = 1;   //通过按键设置页   
      LcdMsg.osdPage = 1;   //当前页  
      LcdMsg.picPage = 1;
      LcdMsg.curPage = 1;
      disInterfacePic(10);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc10(LCD_MSG  *pMsg)
{
    if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
   else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
         LcdMsg.dataTemp = 0;
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
         LcdMsg.dataTemp = 0;
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
       //return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }	
     
     doInterfaceOsdlogic(10,pMsg->pageCnt);
     doInterfacePiclogic(10,0,pMsg->pageCnt);
    return 10;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct10(void)
{

}

extern UINT8 oldDiagnoseContent[18];
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct11(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
    LcdMsg.moduleID = 0;//初始化模块ID
    LcdMsg.dataTemp= 1;
    LcdMsg.dataCnt = 0;
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
    disInterfacePic(11);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc11(LCD_MSG  *pMsg)
{
    //UINT8 i;
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
   else if(pMsg->flag & DOWN_KEY) 
    {
    	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
    	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(11,0,pMsg->pageCnt);
     doInterfaceOsdlogic(11,pMsg->pageCnt);
     doDiagnose(pMsg->moduleID,pMsg->pageCnt,pMsg->dispLenght,0);
    return 11;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct11(void)
{
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct12(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
    LcdMsg.moduleID = 0;//初始化模块ID
    LcdMsg.dataTemp= 1;
    LcdMsg.dataCnt = 0;
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.curPage = 1; 
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
    disInterfacePic(12);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc12(LCD_MSG  *pMsg)
{
	if(pMsg->flag & EXIT_KEY)
	{
		pMsg->flag = 0;
		return ExitMenuNum;
	} 
	else if(pMsg->flag & DOWN_KEY) 
	{
		if( pMsg->pageCnt<200)
		pMsg->pageCnt++;
		pMsg->flag = 0; 
		for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
	} 
	else if(pMsg->flag &UP_KEY) 
	{
		if(pMsg->pageCnt!=0) 
		{
			pMsg->pageCnt-- ; 
		}
		pMsg->flag = 0; 
		for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
	}	
	else if(pMsg->flag & R_GEAR_KEY)
	{
		pMsg->flag = 0x00;
		Video_Choose = RSHIEL_VIDEO_CHANNEL;
		return 0;        
	}
	else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
	{
		pMsg->flag = 0x00;
		Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
		return 0;
	}
	else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
	{
		pMsg->flag = 0x00;
		//return 21;
	}
	else if(pMsg->flag & VIDEO_KEY)   //
	{
		pMsg->flag = 0;
		Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
		return 0x00;
	}
	else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
	{
		pMsg->flag = 0x00;
		return 21;
	}

	doInterfacePiclogic(12,0,pMsg->pageCnt);
	doInterfaceOsdlogic(12,pMsg->pageCnt);
	doDiagnose(pMsg->moduleID,pMsg->pageCnt,pMsg->dispLenght,0);
	return 12;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct12(void)
{
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct13(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
    LcdMsg.moduleID = 0;//初始化模块ID
    LcdMsg.dataTemp= 1;
    LcdMsg.dataCnt = 0;
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
    disInterfacePic(13);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc13(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
   else if(pMsg->flag & DOWN_KEY) 
    {
    	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
    	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }	
    else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     
     doInterfacePiclogic(13,0,pMsg->pageCnt);
     doInterfaceOsdlogic(13,pMsg->pageCnt);
     doDiagnose(pMsg->moduleID,pMsg->pageCnt,pMsg->dispLenght,0);
    return 13;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct13(void)
{
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct14(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
    LcdMsg.moduleID = 0;//初始化模块ID
    LcdMsg.dataTemp= 1;
    LcdMsg.dataCnt = 0;
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
    disInterfacePic(14);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc14(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
   else if(pMsg->flag & DOWN_KEY) 
    {
    	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
    	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
     else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }	
     doInterfacePiclogic(14,0,pMsg->pageCnt);
     doInterfaceOsdlogic(14,pMsg->pageCnt);
     doDiagnose(pMsg->moduleID,pMsg->pageCnt,pMsg->dispLenght,0);
    return 14;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct14(void)
{
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct15(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
    LcdMsg.moduleID = 0;//初始化模块ID
    LcdMsg.dataTemp= 1;
    LcdMsg.dataCnt = 0;
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.curPage = 1; 
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
    disInterfacePic(15);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc15(LCD_MSG  *pMsg)
{
    if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
   else if(pMsg->flag & DOWN_KEY) 
    {
    	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
    	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
       else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(15,0,pMsg->pageCnt);
     doInterfaceOsdlogic(15,pMsg->pageCnt);
     doDiagnose(pMsg->moduleID,pMsg->pageCnt,pMsg->dispLenght,0);
    return 15;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct15(void)
{
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct16(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
    LcdMsg.moduleID = 0;//初始化模块ID
    LcdMsg.dataTemp= 1;
    LcdMsg.dataCnt = 0;
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.curPage = 1; 
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
    disInterfacePic(16);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc16(LCD_MSG  *pMsg)
{
      if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
   else if(pMsg->flag & DOWN_KEY) 
    {
    	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
    	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
       else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
	   
    }	 
     doInterfacePiclogic(16,0,pMsg->pageCnt);
     doInterfaceOsdlogic(16,pMsg->pageCnt);
     doDiagnose(pMsg->moduleID,pMsg->pageCnt,pMsg->dispLenght,0);
    return 16;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct16(void)
{
	for(int i =0; i<18;i++)oldDiagnoseContent[i] = 0;
}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct17(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
    LcdMsg.moduleID = 0;//初始化模块ID
    LcdMsg.dataTemp= 1;
    LcdMsg.dataCnt = 0;
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    LcdMsg.cursor = 0; //光标位置初始化
    disInterfacePic(17); 
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc17(LCD_MSG  *pMsg)
{
    if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;  return ExitMenuNum;
    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if(MultiPgckage_AvailableByte_Num[0]<=ONE_PAGE_ITEM);
     //   else if(MultiPgckage_AvailableByte_Num[0]<=ONE_PAGE_ITEM);
        else if(pMsg->cursor<MultiPgckage_AvailableByte_Num[0]-ONE_PAGE_ITEM) 
        {
         pMsg->cursor+=ONE_PAGE_ITEM;
        }
         pMsg->flag = 0; 
    } 
    else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor>=ONE_PAGE_ITEM) 
      {
        pMsg->cursor-=ONE_PAGE_ITEM; 
      } 
      else
      {
        pMsg->cursor=0;
      }
          pMsg->flag = 0; 
    }
    else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;  //  return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
   // if(Dlay_Engine0_F) 
    { 
     doInterfacePiclogic(17,1,pMsg->pageCnt);
    // Dlay_Engine0_F = 0;
    }
    
     doInterfaceOsdlogic(17,pMsg->pageCnt);
    return 17;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct17(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct18(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.curPage = 1;
    LcdMsg.cursor = 0; //光标位置初始化 
    disInterfacePic(18);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc18(LCD_MSG  *pMsg)
{
if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;  return ExitMenuNum;
    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if(MultiPgckage_AvailableByte_Num[1]<=ONE_PAGE_ITEM);
     //   else if(MultiPgckage_AvailableByte_Num[1]<=ONE_PAGE_ITEM);
        else if(pMsg->cursor<MultiPgckage_AvailableByte_Num[1]-ONE_PAGE_ITEM) 
        {
         pMsg->cursor+=ONE_PAGE_ITEM;
        }
         pMsg->flag = 0; 
    } 
    else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor>=ONE_PAGE_ITEM) 
      {
        pMsg->cursor-=ONE_PAGE_ITEM; 
      } 
      else
      {
        pMsg->cursor=0;
      }
          pMsg->flag = 0; 
    }
    else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;  //  return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
   // if(Dlay_Engine1_F) 
    { 
     doInterfacePiclogic(18,1,pMsg->pageCnt);
    // Dlay_Engine1_F = 0;
    }
    
     doInterfaceOsdlogic(18,pMsg->pageCnt);
    return 18;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct18(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct19(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   	LcdMsg.dataTemp = 0;       //用作输入选中
   
   	if(USR_s_DeviceConfigData.RShieldVideoChannel > 3)
		{
		    USR_s_DeviceConfigData.RShieldVideoChannel = 0x00;
		}
		if(USR_s_DeviceConfigData.MiddleDoorVideoChannel > 3)
		{
		    USR_s_DeviceConfigData.MiddleDoorVideoChannel = 0x00;
		}
		if(USR_s_DeviceConfigData.FrontDoorVideoChannel> 3)                                    
		{
		    USR_s_DeviceConfigData.FrontDoorVideoChannel = 0x00;
		}
		if(USR_s_DeviceConfigData.TopVideoChannel > 3)
		{
		    USR_s_DeviceConfigData.TopVideoChannel = 0x00;
		}

		TV_POWER_H;
		
 	  /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.curPage = 1; 
    disInterfacePic(19);
    
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc19(LCD_MSG  *pMsg)
{
 UINT8 dataTemp;
  if(pMsg->flag & EXIT_KEY)
    {
      pMsg->flag = 0;
      if(pMsg->dataTemp==0) 
      {
        PowerOffSave();
        return ExitMenuNum;
      }
    }
    else if(pMsg->flag & ENTER_KEY)
    { 
       pMsg->flag = 0;
       if(pMsg->dataTemp==0) 
       {  
         pMsg->dataTemp = 1;  //输入选中
       }
       else 
       {
        pMsg->dataTemp = 0; 
       Osd_Video_Change(Osd_State);
       } 
    }
       else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
    if(pMsg->dataTemp==1)  //选中
    { 
           if(pMsg->flag & DOWN_KEY) 
              {
                   if(pMsg->cursor==1) 
                   {
            	        if (USR_s_DeviceConfigData.FrontDoorVideoChannel < 3)
            	          USR_s_DeviceConfigData.FrontDoorVideoChannel++;
            	        else
            	          USR_s_DeviceConfigData.FrontDoorVideoChannel = 0;
              	        Osd_Video_Change(Osd_State);
              	        DelayMs(5);
                        WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,1);
                        DelayMs(5);  
                        Osd_Video_Change(Video_State); 
                      	VideoChannelSelect(USR_s_DeviceConfigData.FrontDoorVideoChannel);
                       
                   } 
                   else if(pMsg->cursor==2) 
                   {
            	        if (USR_s_DeviceConfigData.MiddleDoorVideoChannel < 3)
            	          USR_s_DeviceConfigData.MiddleDoorVideoChannel++;
            	        else
            	          USR_s_DeviceConfigData.MiddleDoorVideoChannel = 0;
            	        
            	          Osd_Video_Change(Osd_State);
            	          DelayMs(5);
                        WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,1);
                        DelayMs(5);  
                        Osd_Video_Change(Video_State); 
                      	VideoChannelSelect(USR_s_DeviceConfigData.MiddleDoorVideoChannel);               
                   }
                   else if(pMsg->cursor==3) 
                   {
            	        if (USR_s_DeviceConfigData.RShieldVideoChannel < 3)
            	          USR_s_DeviceConfigData.RShieldVideoChannel++;
            	        else
            	          USR_s_DeviceConfigData.RShieldVideoChannel = 0;
            	        
            	          Osd_Video_Change(Osd_State);
            	          DelayMs(5);
                        WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,1);  
                        DelayMs(5);
                        Osd_Video_Change(Video_State); 
                      	VideoChannelSelect(USR_s_DeviceConfigData.RShieldVideoChannel);

                   } 
                   else if(pMsg->cursor==4) 
                    {
              	        if (USR_s_DeviceConfigData.TopVideoChannel < 3)
            	          USR_s_DeviceConfigData.TopVideoChannel++;
            	        else
            	          USR_s_DeviceConfigData.TopVideoChannel = 0;
            	          Osd_Video_Change(Osd_State);
            	          DelayMs(5);
                        WriteColor_StringToAddr(3,0x30|CH_COLOR_RED,&dataTemp,1,1);
                        DelayMs(5); 
                        Osd_Video_Change(Video_State);  
                      	VideoChannelSelect(USR_s_DeviceConfigData.TopVideoChannel);

                    }
                    	   // DelayMs(20);
                        	
                      	//	DelayMs(3);  
                   pMsg->flag = 0;
                 }
              else if(pMsg->flag &UP_KEY) 
              {
                    if(pMsg->cursor==1) 
                    { 
            	        if (USR_s_DeviceConfigData.FrontDoorVideoChannel == 0)
            	          USR_s_DeviceConfigData.FrontDoorVideoChannel = 3;
            	        else
            	          USR_s_DeviceConfigData.FrontDoorVideoChannel--;    
            	          Osd_Video_Change(Osd_State);
            	           DelayMs(5);
                        WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,1);
                         DelayMs(5);  
                         Osd_Video_Change(Video_State); 
                      	VideoChannelSelect(USR_s_DeviceConfigData.FrontDoorVideoChannel);
                      	DelayMs(20);
                    }
                     if(pMsg->cursor==2) 
                     {   
            	        if (USR_s_DeviceConfigData.MiddleDoorVideoChannel == 0)
            	          USR_s_DeviceConfigData.MiddleDoorVideoChannel = 3;
            	        else
            	          USR_s_DeviceConfigData.MiddleDoorVideoChannel--;
            	        
            	          Osd_Video_Change(Osd_State);
            	          DelayMs(5);
                        WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,1);  
                        DelayMs(5);
                       	Osd_Video_Change(Video_State);
                      	VideoChannelSelect(USR_s_DeviceConfigData.MiddleDoorVideoChannel);
                      	DelayMs(20);
                       
            	       
                     }
                      if(pMsg->cursor==3) 
                      {
            	        if (USR_s_DeviceConfigData.RShieldVideoChannel == 0)
            	          USR_s_DeviceConfigData.RShieldVideoChannel = 3;
            	        else
            	          USR_s_DeviceConfigData.RShieldVideoChannel--;
            	        
            	          Osd_Video_Change(Osd_State);
            	          DelayMs(5);
                        WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,1);
                        DelayMs(5); 
                      	Osd_Video_Change(Video_State);  
                      	VideoChannelSelect(USR_s_DeviceConfigData.RShieldVideoChannel);
                      	DelayMs(20);
                    
                      	DelayMs(3);
                     
                      } 
                     if(pMsg->cursor==4) 
                      { 
            	        if (USR_s_DeviceConfigData.TopVideoChannel == 0)
            	          USR_s_DeviceConfigData.TopVideoChannel = 3;
            	        else
            	          USR_s_DeviceConfigData.TopVideoChannel--;
            	        
            	          Osd_Video_Change(Osd_State);
            	          DelayMs(5);
                        WriteColor_StringToAddr(3,0x30|CH_COLOR_RED,&dataTemp,1,1);  
                        DelayMs(5);
                        Osd_Video_Change(Video_State); 
                        
                      	VideoChannelSelect(USR_s_DeviceConfigData.TopVideoChannel);
                      	DelayMs(20);
                      	
                      
                       } 
                        pMsg->flag = 0;
              }
                    
           dataTemp  = USR_s_DeviceConfigData.FrontDoorVideoChannel+'0';
           if(pMsg->cursor==1) 
           {
            WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,1);  
           }
            else  WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,0);  
            
           dataTemp  = USR_s_DeviceConfigData.MiddleDoorVideoChannel+'0';
            if(pMsg->cursor==2) 
            {    
            WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,1);
            }
           else  WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,0);
              
              
            
           dataTemp  = USR_s_DeviceConfigData.RShieldVideoChannel +'0';
           
            if(pMsg->cursor==3) 
            {
              
            WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,1);

            }
           else WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,0);
           dataTemp  = USR_s_DeviceConfigData.TopVideoChannel+'0';
           if(pMsg->cursor==4) 
           { 

            WriteColor_StringToAddr(3,0x30|CH_COLOR_RED,&dataTemp,1,1);
           }
           else  WriteColor_StringToAddr(3,0x30|CH_COLOR_RED,&dataTemp,1,0); 
          }
     else    //不选中
    {
          
          if(pMsg->flag & DOWN_KEY) 
          {
              if( pMsg->cursor<200)
               pMsg->cursor++;
               pMsg->flag = 0; 
          } 
         else if(pMsg->flag &UP_KEY) 
          {
            if(pMsg->cursor!=0) 
            {
              pMsg->cursor-- ; 
            }
               pMsg->flag = 0; 
          }
           dataTemp  = USR_s_DeviceConfigData.FrontDoorVideoChannel+'0'; 
           WriteColor_StringToAddr(0,0x30|CH_COLOR_RED,&dataTemp,1,0);
           dataTemp  = USR_s_DeviceConfigData.MiddleDoorVideoChannel+'0';
           WriteColor_StringToAddr(1,0x30|CH_COLOR_RED,&dataTemp,1,0);
           dataTemp  = USR_s_DeviceConfigData.RShieldVideoChannel +'0';
           WriteColor_StringToAddr(2,0x30|CH_COLOR_RED,&dataTemp,1,0);
           dataTemp  = USR_s_DeviceConfigData.TopVideoChannel +'0';
           WriteColor_StringToAddr(3,0x30|CH_COLOR_RED,&dataTemp,1,0);
      
    }
     doInterfacePiclogic(19,2,pMsg->pageCnt);
     doInterfaceOsdlogic(19,pMsg->pageCnt);
    return 19;
   
  
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct19(void)
{

  TV_POWER_L;
	Osd_Video_Change(Osd_State);
	OsdCmd(OsdOpen); 
}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
UINT8 OldPictureConfig[4]; 
void construct20(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   	LcdMsg.dataTemp = 0;       //用作输入选中
   	/******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.curPage = 1; 
	TV_POWER_H;
   
 	 
    disInterfacePic(20);
    if(USR_s_DeviceConfigData.PictureCfg[0] > 10)
		{
		    USR_s_DeviceConfigData.PictureCfg[0]= 5;
		}
		if(USR_s_DeviceConfigData.PictureCfg[1] > 10)
		{
		    USR_s_DeviceConfigData.PictureCfg[1] = 5;
		}
		if(USR_s_DeviceConfigData.PictureCfg[2]> 10)                                    
		{
		    USR_s_DeviceConfigData.PictureCfg[2]= 5;
		}
		if(USR_s_DeviceConfigData.PictureCfg[3] > 10)
		{
		    USR_s_DeviceConfigData.PictureCfg[3] = 5;
		}
		OldPictureConfig[0]=OldPictureConfig[1]=OldPictureConfig[2]=OldPictureConfig[3]=0xff;
		
 	 	Osd_Video_Change(Osd_State);
	  VideoChannelSelect(USR_s_DeviceConfigData.RShieldVideoChannel);
		DelayMs(10);		
		Osd_Video_Change(Video_State);	  
		OsdCmd(OsdOpen); 
  // 	Osd_Video_Change(Osd_State);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc20(LCD_MSG  *pMsg)
{
UINT8 dataTemp,i,j;
static UINT8 chooseF=0;
  if(pMsg->flag & EXIT_KEY)
    {
      pMsg->flag = 0;
      if(pMsg->dataTemp==0) 
      {
        chooseF = 0;
        PowerOffSave();
        return ExitMenuNum;
      }
    }
    else if(pMsg->flag & ENTER_KEY)
    { 
       pMsg->flag = 0;
       if(pMsg->dataTemp==0) 
       {  
         pMsg->dataTemp = 1;  //输入选中
         chooseF = 1;        //选中标志
       }
       else 
       {
        pMsg->dataTemp = 0; 
        chooseF = 0;  
       } 
    }
       else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
   else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }

    if(pMsg->dataTemp==1)  //选中
    { 
          if(pMsg->flag & DOWN_KEY) 
              {

            	     if (USR_s_DeviceConfigData.PictureCfg[pMsg->cursor-1] < 10)
            	     USR_s_DeviceConfigData.PictureCfg[pMsg->cursor-1]++;  
                   pMsg->flag = 0;
                   chooseF= 1;
                 }
              else if(pMsg->flag &UP_KEY) 
              {

            	       if (USR_s_DeviceConfigData.PictureCfg[pMsg->cursor-1]> 0)
            	       USR_s_DeviceConfigData.PictureCfg[pMsg->cursor-1]--;        
                     pMsg->flag = 0;
                     chooseF= 1;
              }
              
                    
                for(i=0;i<4;i++)
                { 
                    if(OldPictureConfig[i]!=USR_s_DeviceConfigData.PictureCfg[i]||chooseF==1) 
                    { 
                       OldPictureConfig[i]=USR_s_DeviceConfigData.PictureCfg[i];
                       dataTemp = 0x0f;  
                        for(j=0;j<30;j++) 
                        { 
                          if(i==(pMsg->cursor-1))
                          {
                             if(j<USR_s_DeviceConfigData.PictureCfg[i]*3) 
                            {
                             WriteColor_StringToAddr(30*i+j,0x30|CH_COLOR_RED,&dataTemp,1,1);
                            } else WriteColor_StringToAddr(30*i+j,0x30|CH_COLOR_RED,(UINT8*)" ",1,1); 
                          } 
                          else 
                         {  
                          if(j<USR_s_DeviceConfigData.PictureCfg[i]*3) 
                          {
                           WriteColor_StringToAddr(30*i+j,0x30|CH_COLOR_RED,&dataTemp,1,0);
                          } else WriteColor_StringToAddr(30*i+j,0x30|CH_COLOR_RED,(UINT8*)" ",1,0);
                          }
                      }
                   } 
                  switch(i) 
                  {
                 	case 0://对比度
        						ContrastCmd(USR_s_DeviceConfigData.PictureCfg[0]);	
        						break;
        					case 1://亮度
        						BrightnessCmd(USR_s_DeviceConfigData.PictureCfg[1]);
        						break;
        					case 2://色度
        						HueCmd(USR_s_DeviceConfigData.PictureCfg[2]); 
        						break;
        					case 3://清晰度
        						SharpnessCmd(USR_s_DeviceConfigData.PictureCfg[3]);
        						break; 
                   } 
                  
                }
                  chooseF=0;


          }
     else    //不选中
    {
          if(pMsg->flag & DOWN_KEY) 
          {
              if( pMsg->cursor<200)
               pMsg->cursor++;
               pMsg->flag = 0; 
          } 
         else if(pMsg->flag &UP_KEY) 
          {
            if(pMsg->cursor!=0) 
            {
              pMsg->cursor-- ; 
            }
               pMsg->flag = 0; 
          }
          dataTemp = 0x0f; 
       if(chooseF==0)
       {
           for(i=0;i<4;i++)
                {    
                 dataTemp = 0x0f;  
                  for(j=0;j<30;j++) 
                  { 
                    
                    if(j<USR_s_DeviceConfigData.PictureCfg[i]*3) 
                    {
                     WriteColor_StringToAddr(30*i+j,0x30|CH_COLOR_RED,&dataTemp,1,0);
                    } else WriteColor_StringToAddr(30*i+j,0x30|CH_COLOR_RED,(UINT8*)" ",1,0);
                  }
                 } 
                   chooseF=1;
              }
        
      
      
    }
     doInterfacePiclogic(20,2,pMsg->pageCnt);
     doInterfaceOsdlogic(20,pMsg->pageCnt);
    return 20;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct20(void)
{
          //TV_POWER1_CTRL        ;//      =0;
 	  //TV_POWER2_CTRL       ;//       =0;	
 	  TV_POWER_L;
 	 	Osd_Video_Change(Osd_State);
  	OsdCmd(OsdOpen); 
}


void construct21(void)
{
    UINT8 i;
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    //LcdMsg.cursor = 1;
    LcdMsg.cursor =  FRONT_DOOR_OPENED_LOAD;
    LcdMsg.cursor<<=1;
    LcdMsg.cursor |= MIDDLE_DOOR_OPENED_LOAD;
   	LcdMsg.dataTemp = 0;       //用作输入选中
    for(i=0;i<3;i++) OsdLeddisBuf[i]=0x00; 
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页    
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.picPage = 1;
    LcdMsg.curPage = 1;
    disInterfacePic(21);
       
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc21(LCD_MSG  *pMsg)
{
 // UINT8 cnt;
  if(pMsg->flag & EXIT_KEY)
    {
      pMsg->flag = 0;
      return 0x01;
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
    else if((FRONT_DOOR_NOR_KEY&pMsg->flag)&&(MIDDLE_DOOR_OPENED_LOAD==0)) 
    {
      pMsg->flag = 0x00;  
      return 0x01;
    }
    else if((FRONT_DOOR_OPENED_LOAD==0)&&(MIDDLE_DOOR_NOR_KEY&pMsg->flag)) 
    {   
      pMsg->flag = 0x00;  
      return 0x01;
    }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_NOT_KEY) 
    {
        pMsg->flag = 0x00;
       return 1;
    }
   // LcdMsg.cursor =  FRONT_DOOR_OPENED_LOAD;
    //LcdMsg.cursor<<=1;
   // LcdMsg.cursor |= MIDDLE_DOOR_OPENED_LOAD;
     doInterfacePiclogic(21,3,pMsg->pageCnt);
     doInterfaceOsdlogic(21,pMsg->pageCnt);
     //for(cnt=0;cnt<3;cnt++)
     //OsdLedStatus[cnt] = LogicOutPut[cnt+1].Load;
    // disLed(OsdLedStatus);
    return 21;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct21(void)
{

}

/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct22(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    disInterfacePic(22);
    StartLogoDelay = SysConfigData.startLogoTime;
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc22(LCD_MSG  *pMsg)
{
   
    if(StartLogoDelay==0) return 1;
   
    if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return 0x01;

    } 
   else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->cursor<200)
         pMsg->cursor++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor!=0) 
      {
        pMsg->cursor-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
  /* else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }  */
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
     doInterfacePiclogic(22,0,pMsg->pageCnt);
     doInterfaceOsdlogic(22,pMsg->pageCnt);
    return 22;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct22(void)
{

}

/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct23(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页
    LcdMsg.curPage = 1;  
    disInterfacePic(23);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc23(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(23,0,pMsg->pageCnt);
     doInterfaceOsdlogic(23,pMsg->pageCnt);	
    
     
    return 23;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct23(void)
{

}

/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct24(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页
    LcdMsg.curPage = 1;  
    disInterfacePic(24);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc24(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
     else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(24,0,pMsg->pageCnt);
     doInterfaceOsdlogic(24,pMsg->pageCnt);
    
    
    return 24;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct24(void)
{

}


/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct25(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    disInterfacePic(25);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc25(LCD_MSG  *pMsg)
	{
		 if(pMsg->flag & EXIT_KEY)
		{
		 pMsg->flag = 0;
		 return ExitMenuNum;
	
		} 
		 else if(pMsg->flag & DOWN_KEY) 
		{
			if( pMsg->pageCnt<200)
			 pMsg->pageCnt++;
			 pMsg->flag = 0; 
		} 
	   else if(pMsg->flag &UP_KEY) 
		{
		  if(pMsg->pageCnt!=0) 
		  {
			pMsg->pageCnt-- ; 
		  }
			 pMsg->flag = 0; 
		}
	   else if(pMsg->flag & R_GEAR_KEY)
		{
		   pMsg->flag = 0x00;
		   Video_Choose = RSHIEL_VIDEO_CHANNEL;
		   return 0;		
		}
	   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
	   {
		   pMsg->flag = 0x00;
		   Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
		   return 0;
	   }
	   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
	   {
		   pMsg->flag = 0x00;
		  return 36;
	   }
		else if(pMsg->flag & VIDEO_KEY)   //
		{
		   pMsg->flag = 0;
		   Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
		   return 0x00;
		}	
		else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
		{
			pMsg->flag = 0x00;
		   return 21;
		}
		 
		 doInterfacePiclogic(25,0,pMsg->pageCnt);
		 doInterfaceOsdlogic(25,pMsg->pageCnt);
		 
		 
		return 25;
	}

/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct25(void)
{

}

/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct26(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页 
    LcdMsg.curPage = 1; 
    disInterfacePic(26);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc26(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
      else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
     else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
    doInterfacePiclogic(26,0,pMsg->pageCnt);
    doInterfaceOsdlogic(26,pMsg->pageCnt);
     
     
    return 26;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct26(void)
{

}

/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct27(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页
    LcdMsg.curPage = 1;  
    disInterfacePic(27);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc27(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
       else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(27,0,pMsg->pageCnt);
     doInterfaceOsdlogic(27,pMsg->pageCnt);
    return 27;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct27(void)
{

}

/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct28(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    disInterfacePic(28);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc28(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
      else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(28,0,pMsg->pageCnt);
     doInterfaceOsdlogic(28,pMsg->pageCnt);
    return 28;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct28(void)
{

}

/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct29(void)
{
    LcdMsg.status.b.disFlag=SHOW_PIC_F;    //默认选中
    LcdMsg.cursor = 1;      //页计数  由于有加减按键  所以从一开始
    LcdMsg.cursor = LcdMsg.menuTwo;
	 /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页
    LcdMsg.curPage = 1;  
   disInterfacePic(29);
   ExitMenuNum = 2;
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc29(LCD_MSG  *pMsg)
{

   if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->cursor<200)
         pMsg->cursor++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor!=0) 
      {
        pMsg->cursor-- ; 
      }
         pMsg->flag = 0; 
    }	 
   else if(pMsg->flag & VIDEO_KEY)
    {
         pMsg->flag = 0;
    }
    else if(pMsg->flag & SILENCE_KEY)
    {
          pMsg->flag = 0;
    }
   else if(pMsg->flag & ENTER_KEY)
    {
       LcdMsg.menuTwo = LcdMsg.cursor; //保存二级菜单光标位置
       pMsg->flag = 0;     
     switch(pMsg->cursor) 
     {
       case 1:  if(MenuConfig[0]>2){ExitMenuNum = 29;  return MenuConfig[0];}break;
       case 2:  if(MenuConfig[1]>2){ExitMenuNum = 29;  return MenuConfig[1];}break;
       case 3:  if(MenuConfig[2]>2){ExitMenuNum = 29;  return MenuConfig[2];}break;
       case 4:  if(MenuConfig[3]>2){ExitMenuNum = 29;  return MenuConfig[3];}break;
       case 5:  if(MenuConfig[4]>2){ExitMenuNum = 29;  return MenuConfig[4];}break;
       case 6:  if(MenuConfig[5]>2){ExitMenuNum = 29;  return MenuConfig[5];}break;
       case 7:  if(MenuConfig[6]>2){ExitMenuNum = 29;  return MenuConfig[6];}break;
       case 8:  if(MenuConfig[7]>2){ExitMenuNum = 29;  return MenuConfig[7];}break; 
      default:break;
     }

    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
     //  return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(29,2,pMsg->pageCnt);
     doInterfaceOsdlogic(29,pMsg->pageCnt);
    return 29;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct29(void)
{

}/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct30(void)
{
    LcdMsg.status.b.disFlag=SHOW_PIC_F;    //默认选中
   LcdMsg.cursor = 1;      //页计数  由于有加减按键  所以从一开始
    LcdMsg.cursor = LcdMsg.menuTwo;
	 /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页
    LcdMsg.curPage = 1;  
   disInterfacePic(30);
   ExitMenuNum = 2;
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc30(LCD_MSG  *pMsg)
{

   if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->cursor<200)
         pMsg->cursor++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor!=0) 
      {
        pMsg->cursor-- ; 
      }
         pMsg->flag = 0; 
    }	 
   else if(pMsg->flag & VIDEO_KEY)
    {
         pMsg->flag = 0;
    }
    else if(pMsg->flag & SILENCE_KEY)
    {
          pMsg->flag = 0;
    }
   else if(pMsg->flag & ENTER_KEY)
    {
       LcdMsg.menuTwo = LcdMsg.cursor; //保存二级菜单光标位置
       pMsg->flag = 0;
     switch(pMsg->cursor) 
     {
       case 1:  if(MenuConfig[0]>2){ExitMenuNum = 30;  return MenuConfig[0];}break;
       case 2:  if(MenuConfig[1]>2){ExitMenuNum = 30;  return MenuConfig[1];}break;
       case 3:  if(MenuConfig[2]>2){ExitMenuNum = 30;  return MenuConfig[2];}break;
       case 4:  if(MenuConfig[3]>2){ExitMenuNum = 30;  return MenuConfig[3];}break;
       case 5:  if(MenuConfig[4]>2){ExitMenuNum = 30;  return MenuConfig[4];}break;
       case 6:  if(MenuConfig[5]>2){ExitMenuNum = 30;  return MenuConfig[5];}break;
       case 7:  if(MenuConfig[6]>2){ExitMenuNum = 30;  return MenuConfig[6];}break;
       case 8:  if(MenuConfig[7]>2){ExitMenuNum = 30;  return MenuConfig[7];}break; 
      default:break;
     }

    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }

   
   
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
     //  return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(30,2,pMsg->pageCnt);
     doInterfaceOsdlogic(30,pMsg->pageCnt);
    return 30;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct30(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct31(void)
{
    LcdMsg.status.b.disFlag=SHOW_PIC_F;    //默认选中
    LcdMsg.cursor = 1;      //页计数  由于有加减按键  所以从一开始
    LcdMsg.cursor = LcdMsg.menuTwo;
	 /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页
    LcdMsg.curPage = 1;  
   disInterfacePic(31);
   ExitMenuNum = 2;
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc31(LCD_MSG  *pMsg)
{

   if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->cursor<200)
         pMsg->cursor++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor!=0) 
      {
        pMsg->cursor-- ; 
      }
         pMsg->flag = 0; 
    }	 
   else if(pMsg->flag & VIDEO_KEY)
    {
         pMsg->flag = 0;
    }
    else if(pMsg->flag & SILENCE_KEY)
    {
          pMsg->flag = 0;
    }
   else if(pMsg->flag & ENTER_KEY)
    {
       LcdMsg.menuTwo = LcdMsg.cursor; //保存二级菜单光标位置
       pMsg->flag = 0;  
     switch(pMsg->cursor) 
     {
       case 1:  if(MenuConfig[0]>2){ExitMenuNum = 31;  return MenuConfig[0];}break;
       case 2:  if(MenuConfig[1]>2){ExitMenuNum = 31;  return MenuConfig[1];}break;
       case 3:  if(MenuConfig[2]>2){ExitMenuNum = 31;  return MenuConfig[2];}break;
       case 4:  if(MenuConfig[3]>2){ExitMenuNum = 31;  return MenuConfig[3];}break;
       case 5:  if(MenuConfig[4]>2){ExitMenuNum = 31;  return MenuConfig[4];}break;
       case 6:  if(MenuConfig[5]>2){ExitMenuNum = 31;  return MenuConfig[5];}break;
       case 7:  if(MenuConfig[6]>2){ExitMenuNum = 31;  return MenuConfig[6];}break;
       case 8:  if(MenuConfig[7]>2){ExitMenuNum = 31;  return MenuConfig[7];}break; 
      default:break;
     }

    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
     //  return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(31,2,pMsg->pageCnt);
     doInterfaceOsdlogic(31,pMsg->pageCnt);
    return 31;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct31(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
UINT8 TPMS_PassWorld[5];
void construct32(void)
{
    UINT8 i;
    LcdMsg.status.b.disFlag = CLEAR_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    LcdMsg.picPage = 1;
    LcdMsg.dataCnt = 0;     //密码索引
    TPMS_PASS_MODE_F = 0;
    TPMS_ENTER_IN_F  = 0; 
    for(i=0;i<4;i++) TPMS_PassWorld[i] = '*';
     
    for(i=0;i<TPMS_SENSOR_NUM;i++) 
    {
      TpmsStudyStatus[i]  = 0; 
      TpmsTimeCnt[i]  = 0; 
    }
    disInterfacePic(32);
    WriteColor_StringToAddr(0,BG_COLOR_CYAN|CH_COLOR_RED,"****",4,0); 
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：胎压学习
******************************************************************************************/
UINT8 msgProc32(LCD_MSG  *pMsg)
{
   UINT8 i;
  // UINT8 key_st;
  // key_st = 0;
    if(TPMS_PASS_MODE_F==0) //输入密码模式
    {
        if(pMsg->flag & EXIT_KEY)
        {
         pMsg->flag = 0;
         if(TPMS_ENTER_IN_F==0)  //
         return ExitMenuNum;
         else 
         {
          LcdMsg.dataCnt++;
          if(LcdMsg.dataCnt>3) LcdMsg.dataCnt=0;//四位密码  
         }
        } 
        else if(pMsg->flag & DOWN_KEY) 
        {
             pMsg->flag = 0; 
             if(TPMS_ENTER_IN_F) 
             {
               if(TPMS_PassWorld[LcdMsg.dataCnt] == '*') TPMS_PassWorld[LcdMsg.dataCnt] = 'A'; 
               else
               {
                 TPMS_PassWorld[LcdMsg.dataCnt]++;
                if(TPMS_PassWorld[LcdMsg.dataCnt]>'Z')    TPMS_PassWorld[LcdMsg.dataCnt] = 'A';
               }  
             // key_st = 1; 
             }
        } 
       else if(pMsg->flag &UP_KEY) 
        {
             pMsg->flag = 0; 
             if(TPMS_ENTER_IN_F) 
             {
               if(TPMS_PassWorld[LcdMsg.dataCnt] == '*') TPMS_PassWorld[LcdMsg.dataCnt] = 'A'; 
               else
               {
                 TPMS_PassWorld[LcdMsg.dataCnt]--;
                 if(TPMS_PassWorld[LcdMsg.dataCnt]<'A')    TPMS_PassWorld[LcdMsg.dataCnt] = 'Z';
               } 
              // key_st = 1; 
             }
        }
        else if(pMsg->flag & ENTER_KEY)
        {
              pMsg->flag = 0;
              if(TPMS_ENTER_IN_F==0)  TPMS_ENTER_IN_F = 1;
              else 
              {
                
                //if((TPMS_PassWorld[0]=='A')&&(TPMS_PassWorld[1]=='B')&&(TPMS_PassWorld[2]=='C')&&(TPMS_PassWorld[3]=='D')) 
                if((TPMS_PassWorld[0]=='*')&&(TPMS_PassWorld[1]=='*')&&(TPMS_PassWorld[2]=='*')&&(TPMS_PassWorld[3]=='*')) 
                {
                   TPMS_PASS_MODE_F = 1;
                   TPMS_ENTER_IN_F  = 0;
                   WriteColor_StringToAddr(0,BG_COLOR_CYAN|CH_COLOR_RED,"PASS",4,0);
                   LcdMsg.status.b.disFlag = SHOW_PIC_F;
                } 
                else 
                {
                    TPMS_ENTER_IN_F = 0;
                    LcdMsg.dataCnt = 0;  
                    for(i=0;i<4;i++) TPMS_PassWorld[i] = '*';
                    WriteColor_StringToAddr(0,BG_COLOR_CYAN|CH_COLOR_RED,"****",4,0);
                }
                 
              }
        }    
      if(TPMS_ENTER_IN_F) 
      {
         
         switch(LcdMsg.dataCnt) 
         {
          case 0:  WriteColor_StringToAddr(0,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[0],1,1);
                   WriteColor_StringToAddr(1,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[1],1,0);
                   WriteColor_StringToAddr(2,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[2],1,0);
                   WriteColor_StringToAddr(3,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[3],1,0);
                   break; 
          case 1:  WriteColor_StringToAddr(0,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[0],1,0);
                   WriteColor_StringToAddr(1,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[1],1,1);
                   WriteColor_StringToAddr(2,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[2],1,0);
                   WriteColor_StringToAddr(3,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[3],1,0);
                   break; 
          case 2:  WriteColor_StringToAddr(0,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[0],1,0);
                   WriteColor_StringToAddr(1,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[1],1,0);
                   WriteColor_StringToAddr(2,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[2],1,1);
                   WriteColor_StringToAddr(3,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[3],1,0);
                   break; 
          case 3:  WriteColor_StringToAddr(0,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[0],1,0);
                   WriteColor_StringToAddr(1,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[1],1,0);
                   WriteColor_StringToAddr(2,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[2],1,0);
                   WriteColor_StringToAddr(3,BG_COLOR_CYAN|CH_COLOR_RED,&TPMS_PassWorld[3],1,1);
                   break; 
         }
      }
    } 
  else 
    {
          if(pMsg->flag & EXIT_KEY)
          {
           pMsg->flag = 0;
           return ExitMenuNum;
          } 
            else if(pMsg->flag & DOWN_KEY) 
          {
              if( pMsg->pageCnt<200)
               pMsg->cursor++;
               pMsg->flag = 0; 
          } 
         else if(pMsg->flag &UP_KEY) 
          {
            if(pMsg->pageCnt!=0) 
            {
              pMsg->cursor-- ; 
            }
               pMsg->flag = 0; 
          }
          if(pMsg->flag & ENTER_KEY) 
          {
              pMsg->flag = 0; 
              switch(pMsg->cursor) 
              {
                case 0:break;
                case 1:TpmsStudyStatus[0] = 0x01;TpmsTimeCnt[0] = 0;break;
                case 2:TpmsStudyStatus[1] = 0x01;TpmsTimeCnt[1] = 0;break;
                case 3:TpmsStudyStatus[2] = 0x01;TpmsTimeCnt[2] = 0;break;
                case 4:TpmsStudyStatus[3] = 0x01;TpmsTimeCnt[3] = 0;break;
                case 5:TpmsStudyStatus[4] = 0x01;TpmsTimeCnt[4] = 0;break;
                case 6:TpmsStudyStatus[5] = 0x01;TpmsTimeCnt[5] = 0;break;  
                case 7:break;  
              }
          }
       for(i=0;i<TPMS_SENSOR_NUM;i++) 
       {
          if(TpmsStudyStatus[i]&&TPMS_1S_F)        // 00->无图片    01->请求  11->配对成功 10->配对失败
          {
            
            if(TpmsTimeCnt[i]<TPMS_SENSOR_OVER_TIME)
            {
               //if(TpmsTimeCnt[i]<TPMS_SENSOR_OVER_TIME-2) 
                TpmsTimeCnt[i]++;
               if(TpmsStudyStatus[i]==0x03)  TpmsTimeCnt[i] = TPMS_SENSOR_OVER_TIME;
               else 
               TXWaitRelay(i);
               //else     TX_TPMS_LearnEnd(i);
              
              
            }
         if(TpmsTimeCnt[i]==TPMS_SENSOR_OVER_TIME) 
           {
             TX_TPMS_LearnEnd(i);
             TpmsTimeCnt[i]=TPMS_SENSOR_OVER_TIME+1; 
             if(TpmsStudyStatus[i]==0x01) TpmsStudyStatus[i] = 0x02;    //真的超时
            }
          }
          if(i==(TPMS_SENSOR_NUM-1)) TPMS_1S_F = 0;

       }
    
    }
   if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(32,0,pMsg->pageCnt);
     doInterfaceOsdlogic(32,pMsg->pageCnt);
    return 32;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct32(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct33(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    LcdMsg.picPage = 1;
    disInterfacePic(33);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc33(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(33,0,pMsg->pageCnt);
     doInterfaceOsdlogic(33,pMsg->pageCnt);
    return 33;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct33(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct34(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
    LcdMsg.moduleID = 0;//初始化模块ID
    LcdMsg.dataTemp= 1;
    LcdMsg.dataCnt = 0;
    /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    LcdMsg.cursor = 0; //光标位置初始化
    disInterfacePic(34); 
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc34(LCD_MSG  *pMsg)
{
    if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;  return ExitMenuNum;
    } 
    else if(pMsg->flag & DOWN_KEY) 
    {
        if(MultiPgckage_AvailableByte_Num[2]<=ONE_PAGE_ITEM);
       // else if(MultiPgckage_AvailableByte_Num[2]<=ONE_PAGE_ITEM);
        else if(pMsg->cursor<MultiPgckage_AvailableByte_Num[2]-ONE_PAGE_ITEM) 
        {
         pMsg->cursor+=ONE_PAGE_ITEM;
        }
         pMsg->flag = 0; 
    } 
    else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->cursor>=ONE_PAGE_ITEM) 
      {
        pMsg->cursor-=ONE_PAGE_ITEM; 
      } 
      else
      {
        pMsg->cursor=0;
      }
          pMsg->flag = 0; 
    }
    else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;  //  return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
   // if(Dlay_Engine0_F) 
    { 
     doInterfacePiclogic(34,1,pMsg->pageCnt);
    // Dlay_Engine0_F = 0;
    }
    
     doInterfaceOsdlogic(34,pMsg->pageCnt);
    return 34;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct34(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct35(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    LcdMsg.picPage = 1;
    
   	Osd_Video_Change(Osd_State);	
  	VideoChannelSelect(2);
		DelayMs(10);		
		Osd_Video_Change(Video_State);	 
		OsdCmd(OsdOpen); 
		TV_POWER_H;
	  
 	  
    disInterfacePic(35);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc35(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
      else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(35,0,pMsg->pageCnt);
     doInterfaceOsdlogic(35,pMsg->pageCnt);
    return 35;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct35(void)
{
   
 	  TV_POWER_L;
 	  Osd_Video_Change(Osd_State);
}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct36(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    LcdMsg.picPage = 1;
    disInterfacePic(36);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc36(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
      else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(36,0,pMsg->pageCnt);
     doInterfaceOsdlogic(36,pMsg->pageCnt);
    return 36;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct36(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct37(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    LcdMsg.picPage = 1;
    disInterfacePic(37);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc37(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
     else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(37,0,pMsg->pageCnt);
     doInterfaceOsdlogic(37,pMsg->pageCnt);
    return 37;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct37(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct38(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    LcdMsg.picPage = 1;
    disInterfacePic(38);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc38(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
      else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(38,0,pMsg->pageCnt);
     doInterfaceOsdlogic(38,pMsg->pageCnt);
    return 38;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct38(void)
{

}
/******************************************************************************************
函数名：void construct0(void)
功能：构造首页页面
参数说明：无
返回值：无
******************************************************************************************/
void construct39(void)
{
    LcdMsg.status.b.disFlag = SHOW_PIC_F;
    LcdMsg.cursor = 1;
   /******************添加多页功能**********************/    
    LcdMsg.pageCnt = 1;   //通过按键设置页   
    LcdMsg.osdPage = 1;   //当前页  
    LcdMsg.curPage = 1;
    LcdMsg.picPage = 1;
    disInterfacePic(39);
}
/******************************************************************************************
函数名：UINT8 msgProc0(LCD_MSG *pMsg)
功能：首页任务处理
******************************************************************************************/
UINT8 msgProc39(LCD_MSG  *pMsg)
{
     if(pMsg->flag & EXIT_KEY)
    {
     pMsg->flag = 0;
     return ExitMenuNum;

    } 
      else if(pMsg->flag & DOWN_KEY) 
    {
        if( pMsg->pageCnt<200)
         pMsg->pageCnt++;
         pMsg->flag = 0; 
    } 
   else if(pMsg->flag &UP_KEY) 
    {
      if(pMsg->pageCnt!=0) 
      {
        pMsg->pageCnt-- ; 
      }
         pMsg->flag = 0; 
    }
   else if(pMsg->flag & R_GEAR_KEY)
    {
       pMsg->flag = 0x00;
       Video_Choose = RSHIEL_VIDEO_CHANNEL;
       return 0;        
    }
   else if(pMsg->flag & MIDDLE_DOOR_OPEN_KEY)
   {
       pMsg->flag = 0x00;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0;
   }
   else if((pMsg->flag & FRONT_DOOR_NOT_CHOSE_KEY) || (pMsg->flag & MIDDLE_DOOR_NOT_CHOSE_KEY))
   {
       pMsg->flag = 0x00;
      // return 21;
   }
    else if(pMsg->flag & VIDEO_KEY)   //
    {
       pMsg->flag = 0;
       Video_Choose = MIDDLE_DOOR_VIDEO_CHANNEL;
       return 0x00;
    }	
    else if(pMsg->flag &INTERFACE_SWITCH_KEY) 
    {
        pMsg->flag = 0x00;
       return 21;
    }
     doInterfacePiclogic(39,0,pMsg->pageCnt);
     doInterfaceOsdlogic(39,pMsg->pageCnt);
    return 39;
}
/******************************************************************************************
函数名：void deconstruct0(void)
功能：首页析构
******************************************************************************************/
void deconstruct39(void)
{

}





